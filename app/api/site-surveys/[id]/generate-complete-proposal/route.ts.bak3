import { NextRequest, NextResponse } from 'next/server';
import { auth } from '@/auth';
import { prisma } from '@/lib/db/prisma';
import { uploadFileToBunny } from '@/lib/bunny/upload';
import { manageDocumentVersions, generateVersionedFilename } from '@/lib/utils/document-versioning';
import { createProposalInSoftOne } from '@/lib/softone/create-proposal';
import Docxtemplater from 'docxtemplater';
import PizZip from 'pizzip';
import ImageModule from 'docxtemplater-image-module-free';
import fs from 'fs';
import path from 'path';

/**
 * Complete Proposal Document Generator - TEMPLATE BASED
 * Uses proposal-template.docx with Docxtemplater
 * 
 * Template Placeholders Required:
 * - {proposalNumber} â†’ FINCODE from ERP (e.g., Î Î¡Î¦0000403)
 * - {date} â†’ Current date
 * - {customerName} â†’ Customer name
 * - {projectName} â†’ Project title
 * - {technicalDescription} â†’ AI-generated technical text (optional)
 * - {products} â†’ Array with: {name}, {brand}, {category}, {quantity}, {unitPrice}, {margin}, {totalPrice}, {specifications}
 * - {services} â†’ Array with: {name}, {category}, {quantity}, {unitPrice}, {totalPrice}
 * - {totalProductsAmount} â†’ Total for products
 * - {totalServicesAmount} â†’ Total for services
 * - {grandTotal} â†’ Total + VAT
 * - {vatAmount} â†’ VAT amount
 */

export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const session = await auth();
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const userId = session.user.id;
    const { id: siteSurveyId } = await params;
    
    // Parse request body to check for flags
    const body = await request.json().catch(() => ({}));
    const skipErpCreation = body.skipErpCreation === true;

    // Fetch site survey with all relations including wizard data with pricing
    const siteSurvey = await prisma.siteSurvey.findUnique({
      where: { id: siteSurveyId },
      include: {
        customer: true,
        lead: true,
        proposals: {
          orderBy: {
            createdAt: 'desc',
          },
          take: 1,
        },
      },
    });
    
    // Get ALL data from database - buildings, products, services, and pricing
    const infrastructureData = siteSurvey?.infrastructureData as any;
    const wizardData = infrastructureData?.wizardData || infrastructureData || {};
    const buildings = wizardData.buildings || [];
    const productPricing = wizardData.productPricing || {};
    const servicePricing = wizardData.servicePricing || {};
    
    // Collect ALL products and services from buildings
    const allProducts: any[] = [];
    const allServices: any[] = [];
    
    buildings.forEach((building: any) => {
      // 1. Central Rack - VoIP PBX products
      building.centralRack?.voipPbx?.forEach((voip: any) => {
        voip.products?.forEach((product: any) => {
          allProducts.push({
            id: product.productId,
            quantity: product.quantity || 1,
          });
        });
        voip.services?.forEach((service: any) => {
          allServices.push({
            id: service.serviceId,
            quantity: service.quantity || 1,
          });
        });
      });
      
      // 2. Central Rack - ATA devices
      building.centralRack?.ata?.forEach((ata: any) => {
        if (ata.isFutureProposal) {
          ata.products?.forEach((product: any) => {
            allProducts.push({
              id: product.productId,
              quantity: product.quantity || 1,
            });
          });
          ata.services?.forEach((service: any) => {
            allServices.push({
              id: service.serviceId,
              quantity: service.quantity || 1,
            });
          });
        }
      });
      
      // 3. Central Rack - Cable Terminations
      building.centralRack?.cableTerminations?.forEach((term: any) => {
        if (term.isFutureProposal) {
          term.services?.forEach((service: any) => {
            allServices.push({
              id: service.serviceId,
              quantity: service.quantity || 1,
            });
          });
        }
      });
      
      // 4. Floors - Racks - Switches
      building.floors?.forEach((floor: any) => {
        floor.racks?.forEach((rack: any) => {
          rack.switches?.forEach((sw: any) => {
            if (sw.isFutureProposal) {
              sw.products?.forEach((product: any) => {
                allProducts.push({
                  id: product.productId,
                  quantity: product.quantity || 1,
                });
              });
              sw.services?.forEach((service: any) => {
                allServices.push({
                  id: service.serviceId,
                  quantity: service.quantity || 1,
                });
              });
            }
          });
        });
        
        // 5. Floors - Rooms - Devices
        floor.rooms?.forEach((room: any) => {
          const multiplier = floor.isTypical ? (floor.repeatCount || 1) : 1;
          const roomMultiplier = room.isTypicalRoom ? (room.identicalRoomsCount || 1) : 1;
          const totalMultiplier = multiplier * roomMultiplier;
          
          room.devices?.forEach((device: any) => {
            if (device.isFutureProposal && device.productId) {
              allProducts.push({
                id: device.productId,
                quantity: (device.quantity || 1) * totalMultiplier,
              });
            }
            device.services?.forEach((service: any) => {
              allServices.push({
                id: service.serviceId,
                quantity: (service.quantity || 1) * totalMultiplier,
              });
            });
          });
          
          // 6. Rooms - Outlets
          room.outlets?.forEach((outlet: any) => {
            if (outlet.isFutureProposal) {
              outlet.services?.forEach((service: any) => {
                allServices.push({
                  id: service.serviceId,
                  quantity: (service.quantity || 1) * totalMultiplier,
                });
              });
            }
          });
        });
      });
    });
    
    console.log('ğŸ“„ Loaded from DB:', {
      buildings: buildings.length,
      products: allProducts.length,
      services: allServices.length,
      productPricing: Object.keys(productPricing).length,
      servicePricing: Object.keys(servicePricing).length,
    });
    console.log('ğŸ” FULL PRODUCT PRICING MAP:', JSON.stringify(productPricing, null, 2));
    console.log('ğŸ” FULL SERVICE PRICING MAP:', JSON.stringify(servicePricing, null, 2));
    console.log('ğŸ§± RAW ERP INPUT DATA:', JSON.stringify({
      products: allProducts,
      services: allServices,
    }, null, 2));

    if (!siteSurvey) {
      return NextResponse.json(
        { error: 'Site survey not found' },
        { status: 404 }
      );
    }

    const latestProposal = siteSurvey.proposals?.[0];
    const customerName = siteSurvey.customer?.name || 'N/A';
    const projectName = siteSurvey.title || 'Site Survey';
    let proposalNumber = latestProposal?.erpProposalNumber || 'TRF>PENDING';
    const assignedUserName = session.user.name || 'N/A';

    // Load AI technical description from database (already have infrastructureData from above)
    const aiContent = infrastructureData?.aiContent || {};
    const technicalDescription = aiContent.technicalDescription || latestProposal?.technicalDesc || '';

    // ALWAYS create new ERP proposal (each generation is a new version)
    console.log('ğŸ”„ Creating NEW ERP proposal...');
    {
      // Try to create ERP order to get FINCODE
      try {
        if (siteSurvey.customer?.trdr && (allProducts.length > 0 || allServices.length > 0)) {
          console.log('ğŸ”„ Attempting to create NEW ERP order for proposal...');
        
          // Fetch product details with MTRL codes
          const productIds = allProducts.map((p: any) => p.id);
        const productsWithMtrl = await prisma.product.findMany({
          where: { id: { in: productIds } },
          select: { id: true, mtrl: true, name: true }
        });
        
        // Prepare ERP lines
        const erpLines = allProducts
          .map((p: any) => {
            const productInfo = productsWithMtrl.find(pm => pm.id === p.id);
            if (!productInfo?.mtrl) return null;
            
            // Get pricing from database (totalPrice is the unit price with margin)
            const pricing = productPricing[p.id] || {};
            const quantity = p.quantity || 1;
            
            // Use totalPrice field which contains unit price with margin already calculated
            const unitPriceWithMargin = parseFloat(pricing.totalPrice || 0);
            const margin = parseFloat(pricing.margin || 0);
            
            console.log(`ğŸ“Š Product ${p.id}: qty=${quantity}, unitPrice=${unitPriceWithMargin}, margin=${margin}%`);
            
            return {
              productId: p.id,
              mtrl: productInfo.mtrl,
              name: productInfo.name || '',
              quantity: quantity,
              unitPrice: unitPriceWithMargin,
              margin: margin,
              totalPrice: unitPriceWithMargin * quantity,
              sodtype: '51', // 51 = Product
            };
          })
          .filter(Boolean) as any[];
        
        // Add services
        const serviceIds = allServices.map((s: any) => s.id);
        const servicesWithMtrl = await prisma.service.findMany({
          where: { id: { in: serviceIds } },
          select: { id: true, code: true, name: true }
        });
        
        allServices.forEach((s: any) => {
          const serviceInfo = servicesWithMtrl.find(sm => sm.id === s.id);
          if (serviceInfo?.code) {
            // Get pricing from database (totalPrice is the unit price with margin)
            const pricing = servicePricing[s.id] || {};
            const quantity = s.quantity || 1;
            
            // Use totalPrice field which contains unit price with margin already calculated
            const unitPriceWithMargin = parseFloat(pricing.totalPrice || 0);
            const margin = parseFloat(pricing.margin || 0);
            
            console.log(`ğŸ“Š Service ${s.id}: qty=${quantity}, unitPrice=${unitPriceWithMargin}, margin=${margin}%`);
            
            erpLines.push({
              productId: s.id,
              mtrl: '3544', // Testing: use fixed MTRL for services
              name: serviceInfo.name || '',
              quantity: quantity,
              unitPrice: unitPriceWithMargin,
              margin: margin,
              totalPrice: unitPriceWithMargin * quantity,
              sodtype: '52', // 52 = Service
            });
          }
        });
        
        console.log('ğŸ§® ERP LINES (detailed):', JSON.stringify(erpLines, null, 2));

        if (erpLines.length > 0) {
          console.log('\nğŸ“Š ===== ITEMS WITH PRICES =====');
          erpLines.forEach((line, idx) => {
            console.log(`${idx + 1}. MTRL: ${line.mtrl}, QTY: ${line.quantity}, PRICE: ${line.unitPrice}, SODTYPE: ${line.sodtype}`);
          });
          console.log('================================\n');
          
          const erpResult = await createProposalInSoftOne({
            series: '7001', // Default series for proposals
            trdr: siteSurvey.customer.trdr.toString(),
            comments: `Complete Proposal - ${projectName}`,
            lines: erpLines,
          });
          
          if (erpResult.success && erpResult.proposalNumber) {
            proposalNumber = erpResult.proposalNumber;
            const erpData = erpResult.erpResponse || {};
            console.log('âœ… ERP order created successfully:', proposalNumber);
            console.log('ğŸ“Š ERP Data:', erpData);
            
            // Save ERP proposal to database with all ERP fields
            if (siteSurvey.customerId) {
              await prisma.proposal.create({
                data: {
                  siteSurveyId: siteSurveyId,
                  leadId: siteSurvey.leadId,
                  customerId: siteSurvey.customerId,
                  projectTitle: projectName,
                  erpProposalNumber: proposalNumber, // FINCODE
                  erpSeries: erpData.SERIES?.toString() || null,
                  erpSeriesNum: erpData.SERIESNUM?.toString() || null,
                  erpFindoc: erpData.FINDOC?.toString() || null,
                  erpSaldocnum: erpData.SALDOCNUM || null,
                  erpTurnover: erpData.TURNOVR || null,
                  erpVatAmount: erpData.VATAMNT || null,
                  technicalDesc: technicalDescription,
                  status: 'APPROVED',
                  stage: 'DOCUMENT_GENERATION',
                  erpSyncStatus: 'SYNCED',
                  generatedBy: userId,
                },
              });
              console.log('âœ… Proposal saved to database with full ERP data');
            }
          } else {
            console.warn('âš ï¸ ERP order creation failed, using fallback:', erpResult.error);
            // Save proposal anyway without ERP number
            if (siteSurvey.customerId) {
              await prisma.proposal.create({
                data: {
                  siteSurveyId: siteSurveyId,
                  leadId: siteSurvey.leadId,
                  customerId: siteSurvey.customerId,
                  projectTitle: projectName,
                  erpProposalNumber: null,
                  technicalDesc: technicalDescription,
                  status: 'DRAFT',
                  stage: 'DOCUMENT_GENERATION',
                  generatedBy: userId,
                },
              });
              console.log('âš ï¸ Proposal saved without ERP number');
            }
          }
        }
        } // Close if (siteSurvey.customer?.trdr...)
      } catch (erpError) {
        console.error('âš ï¸ ERP integration error (continuing with fallback):', erpError);
        // Save proposal anyway without ERP number
        if (siteSurvey.customerId) {
          await prisma.proposal.create({
            data: {
              siteSurveyId: siteSurveyId,
              leadId: siteSurvey.leadId,
              customerId: siteSurvey.customerId,
              projectTitle: projectName,
              erpProposalNumber: null,
              technicalDesc: technicalDescription,
              status: 'DRAFT',
              stage: 'DOCUMENT_GENERATION',
              generatedBy: userId,
            },
          });
          console.log('âš ï¸ Proposal saved after ERP error');
        }
      } // Close try-catch
    } // Close the block for creating ERP proposal

    // Fetch full product details with specifications
    const productIds = allProducts.map((p: any) => p.id);
    const fullProducts = await prisma.product.findMany({
      where: { id: { in: productIds } },
      include: {
        images: true,
        translations: true,
        specifications: {
          include: {
            translations: true,
          },
          orderBy: { order: 'asc' },
        },
        brand: true,
        category: true,
      },
    });

    // Prepare template data
    const currentDate = new Date().toLocaleDateString('el-GR', {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
    });

    // Prepare products data for template
    const productsData = allProducts.map((p: any) => {
      const fullProduct = fullProducts.find(fp => fp.id === p.id);
      const greekTranslation = fullProduct?.translations?.find((t: any) => t.languageCode === 'el');
      
      // Get pricing from database (unitPrice already includes margin calculation)
      const pricing = productPricing[p.id] || {};
      const unitPrice = parseFloat(pricing.unitPrice || pricing.totalPrice || 0);
      const margin = parseFloat(pricing.margin || 0);
      const quantity = p.quantity || 1;
      const totalPrice = unitPrice * quantity;
      
      // Get specifications (filter out N/A)
      const specifications = fullProduct?.specifications
        ?.map((spec: any) => {
          const greekSpec = spec.translations.find((t: any) => t.languageCode === 'el');
          if (greekSpec && greekSpec.specValue && greekSpec.specValue !== 'N/A' && greekSpec.specValue.trim() !== '') {
            return `${greekSpec.specName}: ${greekSpec.specValue}`;
          }
          return null;
        })
        .filter(Boolean)
        .join('\n') || 'Î”ÎµÎ½ Ï…Ï€Î¬ÏÏ‡Î¿Ï…Î½ Ï€ÏÎ¿Î´Î¹Î±Î³ÏÎ±Ï†Î­Ï‚';

      return {
        id: p.id, // CRITICAL: Include ID for lookup later!
        name: greekTranslation?.name || fullProduct?.name || 'N/A',
        brand: fullProduct?.brand?.name || 'N/A',
        category: fullProduct?.category?.name || 'N/A',
        quantity: quantity,
        unitPrice: unitPrice,
        margin: margin,
        totalPrice: totalPrice,
        specifications,
      };
    });

    // Prepare services data for template
    const servicesData = allServices.map((s: any) => {
      // Get pricing from database (unitPrice already includes margin calculation)
      const pricing = servicePricing[s.id] || {};
      const unitPrice = parseFloat(pricing.unitPrice || pricing.totalPrice || 0);
      const quantity = s.quantity || 1;
      const totalPrice = unitPrice * quantity;
      
      return {
        name: s.name || 'N/A',
        category: s.category || 'N/A',
        quantity: quantity,
        unitPrice: unitPrice,
        totalPrice: totalPrice,
      };
    });

    // Calculate totals
    const totalProductsAmount = productsData.reduce((sum: number, p: any) => sum + (p.totalPrice || 0), 0);
    const totalServicesAmount = servicesData.reduce((sum: number, s: any) => sum + (s.totalPrice || 0), 0);
    const subtotal = totalProductsAmount + totalServicesAmount;
    const vatAmount = subtotal * 0.24; // 24% Greek VAT
    const grandTotal = subtotal + vatAmount;

    // Load template
    const templatePath = path.join(process.cwd(), 'public', 'templates', 'proposal-template.docx');
    
    if (!fs.existsSync(templatePath)) {
      console.error('âŒ Template file not found:', templatePath);
      return NextResponse.json(
        { error: 'Proposal template file not found' },
        { status: 500 }
      );
    }

    console.log('ğŸ“Š Using YOUR template with loops for products/services...');
    
    // Generate Infrastructure Description with OpenAI
    let infrastructureDescription = '';
    try {
      const step1Data = {
        title: siteSurvey.title,
        description: siteSurvey.description,
        address: siteSurvey.address,
        city: siteSurvey.city,
        type: siteSurvey.type,
      };
      
      const lastStepInfraDesc = infrastructureData?.infrastructureDesc || '';
      const wizardBuildings = infrastructureData?.wizardData?.buildings || [];
      
      // Prepare context for OpenAI
      const contextPrompt = `
Î”Î·Î¼Î¹Î¿ÏÏÎ³Î·ÏƒÎµ Î¼Î¹Î± Î»ÎµÏ€Ï„Î¿Î¼ÎµÏÎ® Ï€ÎµÏÎ¹Î³ÏÎ±Ï†Î® Ï…Ï€Î¿Î´Î¿Î¼Î®Ï‚ Î³Î¹Î± Ï„ÎµÏ‡Î½Î¹ÎºÎ® Ï€ÏÎ¿ÏƒÏ†Î¿ÏÎ¬ Î¼Îµ Î²Î¬ÏƒÎ· Ï„Î± ÎµÎ¾Î®Ï‚ Î´ÎµÎ´Î¿Î¼Î­Î½Î±:

Î£Î¤ÎŸÎ™Î§Î•Î™Î‘ ÎœÎ•Î›Î•Î¤Î—Î£:
- Î¤Î¯Ï„Î»Î¿Ï‚: ${step1Data.title || 'N/A'}
- Î ÎµÏÎ¹Î³ÏÎ±Ï†Î®: ${step1Data.description || 'N/A'}
- Î¤Î¿Ï€Î¿Î¸ÎµÏƒÎ¯Î±: ${step1Data.address || ''}, ${step1Data.city || ''}
- Î¤ÏÏ€Î¿Ï‚: ${step1Data.type || 'N/A'}

Î¥Î¦Î™Î£Î¤Î‘ÎœÎ•ÎÎ— Î¥Î ÎŸÎ”ÎŸÎœÎ—:
${lastStepInfraDesc || 'Î”ÎµÎ½ Ï…Ï€Î¬ÏÏ‡Î¿Ï…Î½ ÏƒÏ„Î¿Î¹Ï‡ÎµÎ¯Î±'}

ÎšÎ¤Î™Î¡Î™Î‘ & Î”ÎŸÎœÎ—:
${wizardBuildings.length > 0 ? JSON.stringify(wizardBuildings, null, 2) : 'Î”ÎµÎ½ Ï…Ï€Î¬ÏÏ‡Î¿Ï…Î½ Î´ÎµÎ´Î¿Î¼Î­Î½Î±'}

Î“ÏÎ¬ÏˆÎµ Î¼Î¹Î± ÎµÏ€Î±Î³Î³ÎµÎ»Î¼Î±Ï„Î¹ÎºÎ® Ï€ÎµÏÎ¹Î³ÏÎ±Ï†Î® Ï…Ï€Î¿Î´Î¿Î¼Î®Ï‚ (2-3 Ï€Î±ÏÎ¬Î³ÏÎ±Ï†Î¿Î¹) Ï€Î¿Ï… Î½Î± Ï€ÎµÏÎ¹Î»Î±Î¼Î²Î¬Î½ÎµÎ¹:
1. Î¤Î·Î½ Ï…Ï†Î¹ÏƒÏ„Î¬Î¼ÎµÎ½Î· ÎºÎ±Ï„Î¬ÏƒÏ„Î±ÏƒÎ·
2. Î¤Î¹Ï‚ Î±Î½Î¬Î³ÎºÎµÏ‚ Ï€Î¿Ï… ÎµÎ½Ï„Î¿Ï€Î¯ÏƒÏ„Î·ÎºÎ±Î½
3. Î¤Î·Î½ Ï€ÏÎ¿Ï„ÎµÎ¹Î½ÏŒÎ¼ÎµÎ½Î· Î»ÏÏƒÎ·

Î§ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¯Î·ÏƒÎµ ÎµÏ€Î¯ÏƒÎ·Î¼Î· Î³Î»ÏÏƒÏƒÎ± ÎºÎ±Ï„Î¬Î»Î»Î·Î»Î· Î³Î¹Î± Ï„ÎµÏ‡Î½Î¹ÎºÎ® Ï€ÏÎ¿ÏƒÏ†Î¿ÏÎ¬.`;

      const openaiResponse = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`,
        },
        body: JSON.stringify({
          model: 'gpt-4o',
          messages: [
            { role: 'system', content: 'Î•Î¯ÏƒÎ±Î¹ ÎµÎ¹Î´Î¹ÎºÏŒÏ‚ ÏƒÎµ Ï„Î·Î»ÎµÏ€Î¹ÎºÎ¿Î¹Î½Ï‰Î½Î¯ÎµÏ‚ ÎºÎ±Î¹ Î´Î¹ÎºÏ„Ï…Î±ÎºÎ­Ï‚ Ï…Ï€Î¿Î´Î¿Î¼Î­Ï‚ Ï€Î¿Ï… Î³ÏÎ¬Ï†ÎµÎ¹ Ï„ÎµÏ‡Î½Î¹ÎºÎ­Ï‚ Ï€ÏÎ¿ÏƒÏ†Î¿ÏÎ­Ï‚.' },
            { role: 'user', content: contextPrompt }
          ],
          temperature: 0.7,
          max_tokens: 1000,
        }),
      });

      if (openaiResponse.ok) {
        const openaiData = await openaiResponse.json();
        infrastructureDescription = openaiData.choices[0]?.message?.content || lastStepInfraDesc;
        console.log('âœ… Infrastructure description generated with OpenAI');
      } else {
        console.warn('âš ï¸ OpenAI API failed, using existing description');
        infrastructureDescription = lastStepInfraDesc;
      }
    } catch (error) {
      console.error('âš ï¸ Error generating infrastructure description:', error);
      infrastructureDescription = infrastructureData?.infrastructureDesc || 'Î— Ï€ÎµÏÎ¹Î³ÏÎ±Ï†Î® Ï…Ï€Î¿Î´Î¿Î¼Î®Ï‚ Î¸Î± Ï€ÏÎ¿ÏƒÏ„ÎµÎ¸ÎµÎ¯ ÏƒÏÎ½Ï„Î¿Î¼Î±.';
    }

    // Download all product images for template
    const productsWithImages = await Promise.all(
      productsData.map(async (p: any) => {
        const fullProduct = fullProducts.find((fp) => fp.id === p.id);
        let imageBuffer = null;
        
        if (fullProduct?.images && fullProduct.images.length > 0) {
          try {
            const imageUrl = fullProduct.images[0].url;
            console.log(`ğŸ–¼ï¸ Downloading image for ${p.name}:`, imageUrl);
            
            const imageResponse = await fetch(imageUrl);
            if (imageResponse.ok) {
              imageBuffer = await imageResponse.arrayBuffer();
              console.log(`âœ… Image downloaded: ${imageBuffer.byteLength} bytes`);
            }
          } catch (error) {
            console.error(`âŒ Failed to download image for ${p.name}:`, error);
          }
        }
        
        // Get Greek description and specs
        const fullProd = fullProducts.find((fp) => fp.id === p.id);
        const greekTrans = fullProd?.translations?.find((t: any) => t.languageCode === 'el');
        const greekDesc = greekTrans?.description || '';
        
        // Get specifications as text
        const specs = fullProd?.specifications
          ?.map((spec: any) => {
            const greekSpec = spec.translations?.find((t: any) => t.languageCode === 'el');
            if (greekSpec?.specName && greekSpec?.specValue) {
              return `${greekSpec.specName}: ${greekSpec.specValue}`;
            }
            return null;
          })
          .filter(Boolean)
          .join('\n') || '';
        
        // Calculate per-item price: totalPrice / quantity
        const quantity = p.quantity || 1;
        const totalWithMargin = p.totalPrice || 0;
        const perItemPrice = totalWithMargin / quantity;
        
        return {
          index: productsData.indexOf(p) + 1,
          id: p.id,
          name: p.name || 'N/A',
          brand: p.brand || 'N/A',
          category: p.category || 'N/A',
          quantity: quantity,
          unitPrice: perItemPrice.toFixed(2),
          totalPrice: totalWithMargin.toFixed(2),
          description: greekDesc,
          specifications: specs,
          image: imageBuffer ? Buffer.from(imageBuffer) : null,
        };
      })
    );
    
    const servicesWithPricing = servicesData.map((s: any) => {
      const quantity = s.quantity || 1;
      const totalWithMargin = s.totalPrice || 0;
      const perItemPrice = totalWithMargin / quantity;
      
      return {
        index: productsData.length + servicesData.indexOf(s) + 1,
        name: s.name || 'N/A',
        brand: 'Î¥Ï€Î·ÏÎµÏƒÎ¯Î±',
        category: s.category || 'N/A',
        quantity: quantity,
        unitPrice: perItemPrice.toFixed(2),
        totalPrice: totalWithMargin.toFixed(2),
      };
    });
    
    // Prepare template data
    const templateData = {
      PROJECT_TITLE: projectName,
      CUSTOMER_NAME: customerName,
      CUSTOMER_ADDRESS: siteSurvey.customer?.address || '',
      ERP_QUOTE_NUMBER: proposalNumber,
      DATE: currentDate,
      ASSIGNEE_NAME: siteSurvey.assignTo?.name || '',
      ASSIGNED_TO_NAME: siteSurvey.assignFrom?.name || '',
      PROJECT_DESCRIPTION: siteSurvey.description || '',
      INFRASTRUCTURE_DESC: infrastructureDescription,
      TECHNICAL_DESC: technicalDescription || 'Î— Ï„ÎµÏ‡Î½Î¹ÎºÎ® Ï€ÎµÏÎ¹Î³ÏÎ±Ï†Î® Î¸Î± Ï€ÏÎ¿ÏƒÏ„ÎµÎ¸ÎµÎ¯ ÏƒÏÎ½Ï„Î¿Î¼Î±.',
      GRAND_TOTAL: grandTotal.toFixed(2),
      SUBTOTAL: subtotal.toFixed(2),
      VAT_AMOUNT: vatAmount.toFixed(2),
      products: productsWithImages,
      services: servicesWithPricing,
    };
    
    console.log('ğŸ“ Template data ready:', {
      productsCount: productsWithImages.length,
      servicesCount: servicesWithPricing.length,
      productsWithImages: productsWithImages.filter(p => p.image).length,
    });
    
    // Load template
    const content = fs.readFileSync(templatePath, 'binary');
    const zip = new PizZip(content);
    
    // Configure image module
    const imageOpts = {
      centered: false,
      getImage(tagValue: any) {
        return tagValue; // Return the buffer directly
      },
      getSize() {
        return [300, 300]; // 300x300 pixels
      },
    };
    
    // Create Docxtemplater with image module
    const docTemplate = new Docxtemplater(zip, {
      paragraphLoop: true,
      linebreaks: true,
      modules: [new ImageModule(imageOpts)],
    });
    
    // Render template
    docTemplate.render(templateData);
    
    // Generate buffer
    const buffer = docTemplate.getZip().generate({
      type: 'nodebuffer',
      compression: 'DEFLATE',
    });
    
    console.log('âœ… YOUR template rendered successfully!');
    
    /* OLD PROGRAMMATIC CODE REMOVED
    allChildren.push(
      new Paragraph({
        children: [
          new TextRun({
            text: 'Î¤Î•Î§ÎÎ™ÎšÎ— Î Î¡ÎŸÎ¤Î‘Î£Î—',
            bold: true,
            size: 32,
            color: '1F4788',
          }),
        ],
        heading: HeadingLevel.HEADING_1,
        alignment: AlignmentType.CENTER,
        spacing: { before: 200, after: 300 },
      }),
      new Paragraph({
        children: [
          new TextRun({
            text: projectName,
            size: 26,
            bold: true,
          }),
        ],
        alignment: AlignmentType.CENTER,
        spacing: { after: 200 },
      }),
      new Paragraph({
        children: [
          new TextRun({
            text: customerName,
            size: 24,
          }),
        ],
        alignment: AlignmentType.CENTER,
        spacing: { after: 400 },
      }),
      new Paragraph({
        children: [
          new TextRun({
            text: `Î‘ÏÎ¹Î¸Î¼ÏŒÏ‚ Î ÏÎ¿ÏƒÏ†Î¿ÏÎ¬Ï‚: ${proposalNumber}`,
            size: 22,
          }),
        ],
        spacing: { after: 100 },
      }),
      new Paragraph({
        children: [
          new TextRun({
            text: `Î—Î¼ÎµÏÎ¿Î¼Î·Î½Î¯Î±: ${currentDate}`,
            size: 22,
          }),
        ],
        spacing: { after: 600 },
      })
    );
    
    // ========================================
    // INFRASTRUCTURE DESCRIPTION
    // ========================================
    allChildren.push(
      new Paragraph({
        children: [
          new TextRun({
            text: 'Î Î•Î¡Î™Î“Î¡Î‘Î¦Î— Î¥Î ÎŸÎ”ÎŸÎœÎ—Î£',
            bold: true,
            size: 26,
            color: '1F4788',
          }),
        ],
        heading: HeadingLevel.HEADING_2,
        spacing: { before: 400, after: 200 },
      }),
      new Paragraph({
        children: [
          new TextRun({
            text: infrastructureDescription || 'Î— Ï€ÎµÏÎ¹Î³ÏÎ±Ï†Î® Ï…Ï€Î¿Î´Î¿Î¼Î®Ï‚ Î¸Î± Ï€ÏÎ¿ÏƒÏ„ÎµÎ¸ÎµÎ¯ ÏƒÏÎ½Ï„Î¿Î¼Î±.',
            size: 22,
          }),
        ],
        alignment: AlignmentType.JUSTIFIED,
        spacing: { after: 400 },
      })
    );
    
    // ========================================
    // TECHNICAL DESCRIPTION
    // ========================================
    if (technicalDescription) {
      allChildren.push(
        new Paragraph({
          children: [
            new TextRun({
              text: 'Î¤Î•Î§ÎÎ™ÎšÎ— Î Î•Î¡Î™Î“Î¡Î‘Î¦Î—',
              bold: true,
              size: 26,
              color: '1F4788',
            }),
          ],
          heading: HeadingLevel.HEADING_2,
          spacing: { before: 400, after: 200 },
        }),
        new Paragraph({
          children: [
            new TextRun({
              text: technicalDescription,
              size: 22,
            }),
          ],
          alignment: AlignmentType.JUSTIFIED,
          spacing: { after: 400 },
        })
      );
    }
    
    // ========================================
    // PRODUCTS SECTION - EXACTLY LIKE ANALYSIS
    // ========================================
    allChildren.push(
      new Paragraph({
        children: [
          new TextRun({
            text: 'Î Î•Î¡Î™Î“Î¡Î‘Î¦Î— Î Î¡ÎŸÎªÎŸÎÎ¤Î©Î',
            bold: true,
            size: 28,
            color: '1F4788',
          }),
        ],
        heading: HeadingLevel.HEADING_2,
        spacing: { before: 600, after: 300 },
      })
    );
    
    for (let index = 0; index < productsData.length; index++) {
      const product = productsData[index];
      const fullProduct = fullProducts.find((p) => p.id === product.id);
      
      console.log(`ğŸ“ Adding product ${index + 1}/${productsData.length}:`, product.name);
      
      // Product Name
      allChildren.push(
        new Paragraph({
          children: [
            new TextRun({
              text: `${index + 1}. ${product.name}`,
              bold: true,
              size: 24,
            }),
          ],
          spacing: { before: 400, after: 200 },
        })
      );
      
      // Product Image (EXACTLY like analysis document)
      if (fullProduct?.images && fullProduct.images.length > 0) {
        try {
          const imageUrl = fullProduct.images[0].url;
          console.log(`ğŸ–¼ï¸ Downloading image for product ${product.id}:`, imageUrl);
          
          // Download image and convert to buffer
          const imageResponse = await fetch(imageUrl);
          if (imageResponse.ok) {
            const imageBuffer = await imageResponse.arrayBuffer();
            
            // Determine image type from URL
            const imageType = imageUrl.toLowerCase().endsWith('.png') ? 'png' : 'jpg';
            
            console.log(`âœ… Image downloaded successfully: ${imageBuffer.byteLength} bytes, type: ${imageType}`);
            
            allChildren.push(
              new Paragraph({
                children: [
                  new ImageRun({
                    data: Buffer.from(imageBuffer),
                    transformation: {
                      width: 300,
                      height: 300,
                    },
                    type: imageType,
                  }),
                ],
                alignment: AlignmentType.CENTER,
                spacing: { before: 200, after: 200 },
              })
            );
          } else {
            console.error(`âŒ Failed to download image: ${imageResponse.status}`);
          }
        } catch (error) {
          console.error(`âŒ Error embedding image for product ${product.id}:`, error);
          // Skip image if error - DON'T break the loop
        }
      } else {
        console.log(`â„¹ï¸ No images available for product ${product.id}`);
      }
      
      // Description in Greek (EXACTLY like analysis document)
      let greekDescription = '';
      if (fullProduct?.translations && Array.isArray(fullProduct.translations)) {
        const greekTranslation = fullProduct.translations.find((t: any) => t.languageCode === 'el');
        if (greekTranslation?.description) {
          greekDescription = greekTranslation.description;
        }
      }
      
      // Only add description section if Greek translation exists
      if (greekDescription) {
        allChildren.push(
          new Paragraph({
            children: [
              new TextRun({
                text: "Î Î•Î¡Î™Î“Î¡Î‘Î¦Î—:",
                bold: true,
                size: 20,
              }),
            ],
            spacing: { before: 200, after: 100 },
          })
        );
        
        allChildren.push(
          new Paragraph({
            children: [
              new TextRun({
                text: greekDescription,
                size: 18,
              }),
            ],
            spacing: { after: 200 },
          })
        );
      }
      
      // Specifications Table (EXACTLY like analysis document)
      if (greekDescription && fullProduct?.specifications && fullProduct.specifications.length > 0) {
        allChildren.push(
          new Paragraph({
            children: [
              new TextRun({
                text: "Î§Î‘Î¡Î‘ÎšÎ¤Î—Î¡Î™Î£Î¤Î™ÎšÎ‘:",
                bold: true,
                size: 20,
              }),
            ],
            spacing: { before: 200, after: 100 },
          })
        );
      }
      
      // Create specifications table from database
      if (greekDescription && fullProduct?.specifications && fullProduct.specifications.length > 0) {
        const tableRows = [
          // Header row
          new TableRow({
            children: [
              new TableCell({
                children: [new Paragraph({
                  children: [new TextRun({ text: "Î Î¡ÎŸÎ”Î™Î‘Î“Î¡Î‘Î¦Î—", bold: true, size: 18 })],
                  alignment: AlignmentType.CENTER,
                })],
                width: { size: 50, type: WidthType.PERCENTAGE },
              }),
              new TableCell({
                children: [new Paragraph({
                  children: [new TextRun({ text: "Î¤Î™ÎœÎ—", bold: true, size: 18 })],
                  alignment: AlignmentType.CENTER,
                })],
                width: { size: 50, type: WidthType.PERCENTAGE },
              }),
            ],
          }),
        ];
        
        // Add specification rows (use Greek translations)
        fullProduct.specifications.forEach((spec: any) => {
          const greekTranslation = spec.translations?.find((t: any) => t.languageCode === 'el');
          const specName = greekTranslation?.specName || spec.specKey || '';
          const specValue = greekTranslation?.specValue || '';
          
          if (specName && specValue) {
            tableRows.push(
              new TableRow({
                children: [
                  new TableCell({
                    children: [new Paragraph({
                      children: [new TextRun({ text: specName, size: 16 })],
                    })],
                  }),
                  new TableCell({
                    children: [new Paragraph({
                      children: [new TextRun({ text: specValue, size: 16 })],
                    })],
                  }),
                ],
              })
            );
          }
        });
        
        const specsTable = new Table({
          width: { size: 100, type: WidthType.PERCENTAGE },
          rows: tableRows,
        });
        
        allChildren.push(specsTable);
        allChildren.push(
          new Paragraph({
            children: [new TextRun({ text: '', size: 12 })],
            spacing: { after: 300 },
          })
        );
      }
    }
    
    // ========================================
    // SERVICES SECTION
    // ========================================
    if (servicesData.length > 0) {
      allChildren.push(
        new Paragraph({
          children: [
            new TextRun({
              text: 'Î¥Î Î—Î¡Î•Î£Î™Î•Î£ Î¥Î ÎŸÎ£Î¤Î—Î¡Î™ÎÎ—Î£',
              bold: true,
              size: 28,
              color: '1F4788',
            }),
          ],
          heading: HeadingLevel.HEADING_2,
          spacing: { before: 600, after: 300 },
        })
      );
      
      servicesData.forEach((service: any, index: number) => {
        const quantity = service.quantity || 1;
        const totalWithMargin = service.totalPrice || 0;
        const perItemPrice = totalWithMargin / quantity;
        
        allChildren.push(
          new Paragraph({
            children: [
              new TextRun({
                text: `${index + 1}. ${service.name}`,
                bold: true,
                size: 24,
              }),
            ],
            spacing: { before: 300, after: 100 },
          }),
          new Paragraph({
            children: [
              new TextRun({ text: 'Î Î¿ÏƒÏŒÏ„Î·Ï„Î±: ', bold: true, size: 20 }),
              new TextRun({ text: quantity.toString(), size: 20 }),
            ],
            spacing: { after: 100 },
          }),
          new Paragraph({
            children: [
              new TextRun({ text: 'Î¤Î¹Î¼Î® ÎœÎ¿Î½Î¬Î´Î±Ï‚: ', bold: true, size: 20 }),
              new TextRun({ text: `â‚¬${perItemPrice.toFixed(2)}`, size: 20 }),
            ],
            spacing: { after: 100 },
          }),
          new Paragraph({
            children: [
              new TextRun({ text: 'Î£ÏÎ½Î¿Î»Î¿: ', bold: true, size: 20, color: 'FF0000' }),
              new TextRun({ text: `â‚¬${totalWithMargin.toFixed(2)}`, size: 20, bold: true, color: 'FF0000' }),
            ],
            spacing: { after: 300 },
          })
        );
      });
    }
    
    // ========================================
    // PRICING TABLE - ALL PRODUCTS & SERVICES
    // ========================================
    allChildren.push(
      new Paragraph({
        children: [
          new TextRun({
            text: 'ÎŸÎ™ÎšÎŸÎÎŸÎœÎ™ÎšÎ— Î Î¡ÎŸÎ¤Î‘Î£Î— - Î Î™ÎÎ‘ÎšÎ‘Î£ Î¤Î™ÎœÎ©Î',
            bold: true,
            size: 28,
            color: '1F4788',
          }),
        ],
        heading: HeadingLevel.HEADING_2,
        spacing: { before: 600, after: 300 },
      })
    );
    
    const pricingTableRows = [
      // Header
      new TableRow({
        children: [
          new TableCell({
            children: [new Paragraph({ children: [new TextRun({ text: 'Î‘/Î‘', bold: true, size: 20 })], alignment: AlignmentType.CENTER })],
            width: { size: 8, type: WidthType.PERCENTAGE },
          }),
          new TableCell({
            children: [new Paragraph({ children: [new TextRun({ text: 'Î Î¡ÎŸÎªÎŸÎ/Î¥Î Î—Î¡Î•Î£Î™Î‘', bold: true, size: 20 })] })],
            width: { size: 37, type: WidthType.PERCENTAGE },
          }),
          new TableCell({
            children: [new Paragraph({ children: [new TextRun({ text: 'BRAND', bold: true, size: 20 })] })],
            width: { size: 15, type: WidthType.PERCENTAGE },
          }),
          new TableCell({
            children: [new Paragraph({ children: [new TextRun({ text: 'Î ÎŸÎ£.', bold: true, size: 20 })], alignment: AlignmentType.CENTER })],
            width: { size: 10, type: WidthType.PERCENTAGE },
          }),
          new TableCell({
            children: [new Paragraph({ children: [new TextRun({ text: 'Î¤Î™ÎœÎ— (â‚¬)', bold: true, size: 20 })], alignment: AlignmentType.RIGHT })],
            width: { size: 15, type: WidthType.PERCENTAGE },
          }),
          new TableCell({
            children: [new Paragraph({ children: [new TextRun({ text: 'Î£Î¥ÎÎŸÎ›ÎŸ (â‚¬)', bold: true, size: 20 })], alignment: AlignmentType.RIGHT })],
            width: { size: 15, type: WidthType.PERCENTAGE },
          }),
        ],
      }),
    ];
    
    // Add all products to table
    productsData.forEach((product: any, index: number) => {
      const quantity = product.quantity || 1;
      const totalWithMargin = product.totalPrice || 0;
      const perItemPrice = totalWithMargin / quantity;
      
      pricingTableRows.push(
        new TableRow({
          children: [
            new TableCell({
              children: [new Paragraph({ children: [new TextRun({ text: (index + 1).toString(), size: 18 })], alignment: AlignmentType.CENTER })],
            }),
            new TableCell({
              children: [new Paragraph({ children: [new TextRun({ text: product.name || 'N/A', size: 18 })] })],
            }),
            new TableCell({
              children: [new Paragraph({ children: [new TextRun({ text: product.brand || 'N/A', size: 18 })] })],
            }),
            new TableCell({
              children: [new Paragraph({ children: [new TextRun({ text: quantity.toString(), size: 18 })], alignment: AlignmentType.CENTER })],
            }),
            new TableCell({
              children: [new Paragraph({ children: [new TextRun({ text: perItemPrice.toFixed(2), size: 18 })], alignment: AlignmentType.RIGHT })],
            }),
            new TableCell({
              children: [new Paragraph({ children: [new TextRun({ text: totalWithMargin.toFixed(2), size: 18, bold: true })], alignment: AlignmentType.RIGHT })],
            }),
          ],
        })
      );
    });
    
    // Add all services to table
    servicesData.forEach((service: any, index: number) => {
      const quantity = service.quantity || 1;
      const totalWithMargin = service.totalPrice || 0;
      const perItemPrice = totalWithMargin / quantity;
      
      pricingTableRows.push(
        new TableRow({
          children: [
            new TableCell({
              children: [new Paragraph({ children: [new TextRun({ text: (productsData.length + index + 1).toString(), size: 18 })], alignment: AlignmentType.CENTER })],
            }),
            new TableCell({
              children: [new Paragraph({ children: [new TextRun({ text: service.name || 'N/A', size: 18, italic: true })] })],
            }),
            new TableCell({
              children: [new Paragraph({ children: [new TextRun({ text: 'Î¥Ï€Î·ÏÎµÏƒÎ¯Î±', size: 18, italic: true })] })],
            }),
            new TableCell({
              children: [new Paragraph({ children: [new TextRun({ text: quantity.toString(), size: 18 })], alignment: AlignmentType.CENTER })],
            }),
            new TableCell({
              children: [new Paragraph({ children: [new TextRun({ text: perItemPrice.toFixed(2), size: 18 })], alignment: AlignmentType.RIGHT })],
            }),
            new TableCell({
              children: [new Paragraph({ children: [new TextRun({ text: totalWithMargin.toFixed(2), size: 18, bold: true })], alignment: AlignmentType.RIGHT })],
            }),
          ],
        })
      );
    });
    
    // Add totals rows
    pricingTableRows.push(
      // Subtotal
      new TableRow({
        children: [
          new TableCell({
            children: [new Paragraph({ children: [new TextRun({ text: 'Î¥Î ÎŸÎ£Î¥ÎÎŸÎ›ÎŸ', bold: true, size: 20 })], alignment: AlignmentType.RIGHT })],
            columnSpan: 5,
          }),
          new TableCell({
            children: [new Paragraph({ children: [new TextRun({ text: `â‚¬${subtotal.toFixed(2)}`, bold: true, size: 20 })], alignment: AlignmentType.RIGHT })],
          }),
        ],
      }),
      // VAT
      new TableRow({
        children: [
          new TableCell({
            children: [new Paragraph({ children: [new TextRun({ text: 'Î¦Î Î‘ 24%', size: 20 })], alignment: AlignmentType.RIGHT })],
            columnSpan: 5,
          }),
          new TableCell({
            children: [new Paragraph({ children: [new TextRun({ text: `â‚¬${vatAmount.toFixed(2)}`, size: 20 })], alignment: AlignmentType.RIGHT })],
          }),
        ],
      }),
      // Grand Total
      new TableRow({
        children: [
          new TableCell({
            children: [new Paragraph({ children: [new TextRun({ text: 'Î“Î•ÎÎ™ÎšÎŸ Î£Î¥ÎÎŸÎ›ÎŸ', bold: true, size: 22, color: 'FF0000' })], alignment: AlignmentType.RIGHT })],
            columnSpan: 5,
          }),
          new TableCell({
            children: [new Paragraph({ children: [new TextRun({ text: `â‚¬${grandTotal.toFixed(2)}`, bold: true, size: 24, color: 'FF0000' })], alignment: AlignmentType.RIGHT })],
          }),
        ],
      })
    );
    
    const pricingTable = new Table({
      width: { size: 100, type: WidthType.PERCENTAGE },
      rows: pricingTableRows,
    });
    
    allChildren.push(pricingTable);
    
    // ========================================
    // CREATE DOCUMENT
    // ========================================
    const doc = new Document({
      sections: [{
        properties: {
          page: {
            margin: {
              top: 1440,
              right: 1440,
              bottom: 1440,
              left: 1440,
            },
          },
        },
        children: allChildren,
      }],
    });
    
    // Generate buffer
    const buffer = await Packer.toBuffer(doc);
    console.log('âœ… Complete proposal document generated programmatically');

    // Save to database with versioning
    const baseFileName = `Complete-Proposal_${siteSurvey.title || 'SiteSurvey'}_${new Date().toISOString().split('T')[0]}`;
    
    const { nextVersion } = await manageDocumentVersions({
      entityType: 'SITESURVEY',
      entityId: siteSurveyId,
      documentType: 'complete-proposal',
      baseFileName,
      fileExtension: 'docx',
    });

    const versionedFilename = generateVersionedFilename(baseFileName, nextVersion, 'docx');

    console.log('ğŸ“¤ Uploading complete proposal to BunnyCDN:', versionedFilename);

    const uploadResult = await uploadFileToBunny(
      Buffer.from(buffer),
      versionedFilename,
      'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
    );

    console.log('âœ… Complete proposal uploaded:', uploadResult.url);

    await prisma.file.create({
      data: {
        name: versionedFilename,
        url: uploadResult.url,
        filetype: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
        size: buffer.byteLength,
        type: 'SITESURVEY',
        entityId: siteSurveyId,
      },
    });

    // Return the document for download
    return new NextResponse(Buffer.from(buffer), {
      status: 200,
      headers: {
        'Content-Type': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
        'Content-Disposition': `attachment; filename="${encodeURIComponent(versionedFilename)}"`,
      },
    });
    
  } catch (error: any) {
    console.error('âŒ Error generating complete proposal:', error);
    return NextResponse.json(
      {
        error: 'Failed to generate complete proposal',
        details: error.message,
      },
      { status: 500 }
    );
  }
}

