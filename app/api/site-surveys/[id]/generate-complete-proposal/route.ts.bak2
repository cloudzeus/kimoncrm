import { NextRequest, NextResponse } from 'next/server';
import { auth } from '@/auth';
import { prisma } from '@/lib/db/prisma';
import { uploadFileToBunny } from '@/lib/bunny/upload';
import { manageDocumentVersions, generateVersionedFilename } from '@/lib/utils/document-versioning';
import { createProposalInSoftOne } from '@/lib/softone/create-proposal';
import Docxtemplater from 'docxtemplater';
import PizZip from 'pizzip';
import fs from 'fs';
import path from 'path';

/**
 * Complete Proposal Document Generator - TEMPLATE BASED
 * Uses proposal-template.docx with Docxtemplater
 * 
 * Template Placeholders Required:
 * - {proposalNumber} â†’ FINCODE from ERP (e.g., Î Î¡Î¦0000403)
 * - {date} â†’ Current date
 * - {customerName} â†’ Customer name
 * - {projectName} â†’ Project title
 * - {technicalDescription} â†’ AI-generated technical text (optional)
 * - {products} â†’ Array with: {name}, {brand}, {category}, {quantity}, {unitPrice}, {margin}, {totalPrice}, {specifications}
 * - {services} â†’ Array with: {name}, {category}, {quantity}, {unitPrice}, {totalPrice}
 * - {totalProductsAmount} â†’ Total for products
 * - {totalServicesAmount} â†’ Total for services
 * - {grandTotal} â†’ Total + VAT
 * - {vatAmount} â†’ VAT amount
 */

export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const session = await auth();
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const userId = session.user.id;
    const { id: siteSurveyId } = await params;
    
    // Parse request body to check for flags
    const body = await request.json().catch(() => ({}));
    const skipErpCreation = body.skipErpCreation === true;

    // Fetch site survey with all relations including wizard data with pricing
    const siteSurvey = await prisma.siteSurvey.findUnique({
      where: { id: siteSurveyId },
      include: {
        customer: true,
        lead: true,
        proposals: {
          orderBy: {
            createdAt: 'desc',
          },
          take: 1,
        },
      },
    });
    
    // Get ALL data from database - buildings, products, services, and pricing
    const infrastructureData = siteSurvey?.infrastructureData as any;
    const wizardData = infrastructureData?.wizardData || infrastructureData || {};
    const buildings = wizardData.buildings || [];
    const productPricing = wizardData.productPricing || {};
    const servicePricing = wizardData.servicePricing || {};
    
    // Collect ALL products and services from buildings
    const allProducts: any[] = [];
    const allServices: any[] = [];
    
    buildings.forEach((building: any) => {
      // 1. Central Rack - VoIP PBX products
      building.centralRack?.voipPbx?.forEach((voip: any) => {
        voip.products?.forEach((product: any) => {
          allProducts.push({
            id: product.productId,
            quantity: product.quantity || 1,
          });
        });
        voip.services?.forEach((service: any) => {
          allServices.push({
            id: service.serviceId,
            quantity: service.quantity || 1,
          });
        });
      });
      
      // 2. Central Rack - ATA devices
      building.centralRack?.ata?.forEach((ata: any) => {
        if (ata.isFutureProposal) {
          ata.products?.forEach((product: any) => {
            allProducts.push({
              id: product.productId,
              quantity: product.quantity || 1,
            });
          });
          ata.services?.forEach((service: any) => {
            allServices.push({
              id: service.serviceId,
              quantity: service.quantity || 1,
            });
          });
        }
      });
      
      // 3. Central Rack - Cable Terminations
      building.centralRack?.cableTerminations?.forEach((term: any) => {
        if (term.isFutureProposal) {
          term.services?.forEach((service: any) => {
            allServices.push({
              id: service.serviceId,
              quantity: service.quantity || 1,
            });
          });
        }
      });
      
      // 4. Floors - Racks - Switches
      building.floors?.forEach((floor: any) => {
        floor.racks?.forEach((rack: any) => {
          rack.switches?.forEach((sw: any) => {
            if (sw.isFutureProposal) {
              sw.products?.forEach((product: any) => {
                allProducts.push({
                  id: product.productId,
                  quantity: product.quantity || 1,
                });
              });
              sw.services?.forEach((service: any) => {
                allServices.push({
                  id: service.serviceId,
                  quantity: service.quantity || 1,
                });
              });
            }
          });
        });
        
        // 5. Floors - Rooms - Devices
        floor.rooms?.forEach((room: any) => {
          const multiplier = floor.isTypical ? (floor.repeatCount || 1) : 1;
          const roomMultiplier = room.isTypicalRoom ? (room.identicalRoomsCount || 1) : 1;
          const totalMultiplier = multiplier * roomMultiplier;
          
          room.devices?.forEach((device: any) => {
            if (device.isFutureProposal && device.productId) {
              allProducts.push({
                id: device.productId,
                quantity: (device.quantity || 1) * totalMultiplier,
              });
            }
            device.services?.forEach((service: any) => {
              allServices.push({
                id: service.serviceId,
                quantity: (service.quantity || 1) * totalMultiplier,
              });
            });
          });
          
          // 6. Rooms - Outlets
          room.outlets?.forEach((outlet: any) => {
            if (outlet.isFutureProposal) {
              outlet.services?.forEach((service: any) => {
                allServices.push({
                  id: service.serviceId,
                  quantity: (service.quantity || 1) * totalMultiplier,
                });
              });
            }
          });
        });
      });
    });
    
    console.log('ğŸ“„ Loaded from DB:', {
      buildings: buildings.length,
      products: allProducts.length,
      services: allServices.length,
      productPricing: Object.keys(productPricing).length,
      servicePricing: Object.keys(servicePricing).length,
    });
    console.log('ğŸ” FULL PRODUCT PRICING MAP:', JSON.stringify(productPricing, null, 2));
    console.log('ğŸ” FULL SERVICE PRICING MAP:', JSON.stringify(servicePricing, null, 2));
    console.log('ğŸ§± RAW ERP INPUT DATA:', JSON.stringify({
      products: allProducts,
      services: allServices,
    }, null, 2));

    if (!siteSurvey) {
      return NextResponse.json(
        { error: 'Site survey not found' },
        { status: 404 }
      );
    }

    const latestProposal = siteSurvey.proposals?.[0];
    const customerName = siteSurvey.customer?.name || 'N/A';
    const projectName = siteSurvey.title || 'Site Survey';
    let proposalNumber = latestProposal?.erpProposalNumber || 'TRF>PENDING';
    const assignedUserName = session.user.name || 'N/A';

    // Load AI technical description from database (already have infrastructureData from above)
    const aiContent = infrastructureData?.aiContent || {};
    const technicalDescription = aiContent.technicalDescription || latestProposal?.technicalDesc || '';

    // Check if proposal already exists with ERP number
    const existingErpProposal = await prisma.proposal.findFirst({
      where: {
        siteSurveyId: siteSurveyId,
        erpProposalNumber: { not: null },
      },
      select: {
        id: true,
        erpProposalNumber: true, // This IS the FINCODE from SoftOne
        erpQuoteNumber: true,
        erpSeries: true,
        erpSeriesNum: true,
        createdAt: true,
      },
    });

    // If ERP proposal exists and user hasn't confirmed to skip, ask for confirmation
    if (existingErpProposal && !skipErpCreation) {
      console.log('âš ï¸ Existing ERP proposal found:', existingErpProposal);
      return NextResponse.json({
        warningType: 'ERP_PROPOSAL_EXISTS',
        message: 'Î¥Ï€Î¬ÏÏ‡ÎµÎ¹ Î®Î´Î· Ï€ÏÎ¿ÏƒÏ†Î¿ÏÎ¬ ÏƒÏ„Î¿ ERP Î³Î¹Î± Î±Ï…Ï„Î® Ï„Î· Î¼ÎµÎ»Î­Ï„Î·',
        existingProposal: {
          erpProposalNumber: existingErpProposal.erpProposalNumber, // FINCODE
          erpQuoteNumber: existingErpProposal.erpQuoteNumber,
          series: existingErpProposal.erpSeries,
          seriesNum: existingErpProposal.erpSeriesNum,
          createdAt: existingErpProposal.createdAt,
        },
        question: 'Î˜Î­Î»ÎµÏ„Îµ Î½Î± Î´Î·Î¼Î¹Î¿Ï…ÏÎ³Î®ÏƒÎµÏ„Îµ Î½Î­Î± Ï€ÏÎ¿ÏƒÏ†Î¿ÏÎ¬ ÏƒÏ„Î¿ ERP;',
        actions: {
          useExisting: 'Î§ÏÎ®ÏƒÎ· Ï…Ï€Î¬ÏÏ‡Î¿Ï…ÏƒÎ±Ï‚ Ï€ÏÎ¿ÏƒÏ†Î¿ÏÎ¬Ï‚ (ÏƒÏ…Î½Î¹ÏƒÏ„Î¬Ï„Î±Î¹)',
          createNew: 'Î”Î·Î¼Î¹Î¿Ï…ÏÎ³Î¯Î± Î½Î­Î±Ï‚ Ï€ÏÎ¿ÏƒÏ†Î¿ÏÎ¬Ï‚ ÏƒÏ„Î¿ ERP',
        },
      }, { status: 409 }); // 409 Conflict
    }

    // Reset proposal number based on user choice
    // If user chose to skip ERP creation, use existing proposal number
    if (skipErpCreation && existingErpProposal) {
      proposalNumber = existingErpProposal.erpProposalNumber || existingErpProposal.erpQuoteNumber || '';
      console.log('â„¹ï¸ Using existing ERP proposal number:', proposalNumber);
    }
    // Only create new ERP order if no existing proposal
    else if (!existingErpProposal) {
      // Try to create ERP order to get FINCODE
      try {
        if (siteSurvey.customer?.trdr && (allProducts.length > 0 || allServices.length > 0)) {
          console.log('ğŸ”„ Attempting to create NEW ERP order for proposal...');
        
          // Fetch product details with MTRL codes
          const productIds = allProducts.map((p: any) => p.id);
        const productsWithMtrl = await prisma.product.findMany({
          where: { id: { in: productIds } },
          select: { id: true, mtrl: true, name: true }
        });
        
        // Prepare ERP lines
        const erpLines = allProducts
          .map((p: any) => {
            const productInfo = productsWithMtrl.find(pm => pm.id === p.id);
            if (!productInfo?.mtrl) return null;
            
            // Get pricing from database (totalPrice is the unit price with margin)
            const pricing = productPricing[p.id] || {};
            const quantity = p.quantity || 1;
            
            // Use totalPrice field which contains unit price with margin already calculated
            const unitPriceWithMargin = parseFloat(pricing.totalPrice || 0);
            const margin = parseFloat(pricing.margin || 0);
            
            console.log(`ğŸ“Š Product ${p.id}: qty=${quantity}, unitPrice=${unitPriceWithMargin}, margin=${margin}%`);
            
            return {
              productId: p.id,
              mtrl: productInfo.mtrl,
              name: productInfo.name || '',
              quantity: quantity,
              unitPrice: unitPriceWithMargin,
              margin: margin,
              totalPrice: unitPriceWithMargin * quantity,
              sodtype: '51', // 51 = Product
            };
          })
          .filter(Boolean) as any[];
        
        // Add services
        const serviceIds = allServices.map((s: any) => s.id);
        const servicesWithMtrl = await prisma.service.findMany({
          where: { id: { in: serviceIds } },
          select: { id: true, code: true, name: true }
        });
        
        allServices.forEach((s: any) => {
          const serviceInfo = servicesWithMtrl.find(sm => sm.id === s.id);
          if (serviceInfo?.code) {
            // Get pricing from database (totalPrice is the unit price with margin)
            const pricing = servicePricing[s.id] || {};
            const quantity = s.quantity || 1;
            
            // Use totalPrice field which contains unit price with margin already calculated
            const unitPriceWithMargin = parseFloat(pricing.totalPrice || 0);
            const margin = parseFloat(pricing.margin || 0);
            
            console.log(`ğŸ“Š Service ${s.id}: qty=${quantity}, unitPrice=${unitPriceWithMargin}, margin=${margin}%`);
            
            erpLines.push({
              productId: s.id,
              mtrl: '3544', // Testing: use fixed MTRL for services
              name: serviceInfo.name || '',
              quantity: quantity,
              unitPrice: unitPriceWithMargin,
              margin: margin,
              totalPrice: unitPriceWithMargin * quantity,
              sodtype: '52', // 52 = Service
            });
          }
        });
        
        console.log('ğŸ§® ERP LINES (detailed):', JSON.stringify(erpLines, null, 2));

        if (erpLines.length > 0) {
          console.log('\nğŸ“Š ===== ITEMS WITH PRICES =====');
          erpLines.forEach((line, idx) => {
            console.log(`${idx + 1}. MTRL: ${line.mtrl}, QTY: ${line.quantity}, PRICE: ${line.unitPrice}, SODTYPE: ${line.sodtype}`);
          });
          console.log('================================\n');
          
          const erpResult = await createProposalInSoftOne({
            series: '7001', // Default series for proposals
            trdr: siteSurvey.customer.trdr.toString(),
            comments: `Complete Proposal - ${projectName}`,
            lines: erpLines,
          });
          
          if (erpResult.success && erpResult.proposalNumber) {
            proposalNumber = erpResult.proposalNumber;
            const erpData = erpResult.erpResponse || {};
            console.log('âœ… ERP order created successfully:', proposalNumber);
            console.log('ğŸ“Š ERP Data:', erpData);
            
            // Save ERP proposal to database with all ERP fields
            if (siteSurvey.customerId) {
              await prisma.proposal.create({
                data: {
                  siteSurveyId: siteSurveyId,
                  leadId: siteSurvey.leadId,
                  customerId: siteSurvey.customerId,
                  projectTitle: projectName,
                  erpProposalNumber: proposalNumber, // FINCODE
                  erpSeries: erpData.SERIES?.toString() || null,
                  erpSeriesNum: erpData.SERIESNUM?.toString() || null,
                  erpFindoc: erpData.FINDOC?.toString() || null,
                  erpSaldocnum: erpData.SALDOCNUM || null,
                  erpTurnover: erpData.TURNOVR || null,
                  erpVatAmount: erpData.VATAMNT || null,
                  technicalDesc: technicalDescription,
                  status: 'APPROVED',
                  stage: 'DOCUMENT_GENERATION',
                  erpSyncStatus: 'SYNCED',
                  generatedBy: userId,
                },
              });
              console.log('âœ… Proposal saved to database with full ERP data');
            }
          } else {
            console.warn('âš ï¸ ERP order creation failed, using fallback:', erpResult.error);
            // Save proposal anyway without ERP number
            if (siteSurvey.customerId) {
              await prisma.proposal.create({
                data: {
                  siteSurveyId: siteSurveyId,
                  leadId: siteSurvey.leadId,
                  customerId: siteSurvey.customerId,
                  projectTitle: projectName,
                  erpProposalNumber: null,
                  technicalDesc: technicalDescription,
                  status: 'DRAFT',
                  stage: 'DOCUMENT_GENERATION',
                  generatedBy: userId,
                },
              });
              console.log('âš ï¸ Proposal saved without ERP number');
            }
          }
        }
        } // Close if (siteSurvey.customer?.trdr...)
      } catch (erpError) {
        console.error('âš ï¸ ERP integration error (continuing with fallback):', erpError);
        // Save proposal anyway without ERP number
        if (siteSurvey.customerId) {
          await prisma.proposal.create({
            data: {
              siteSurveyId: siteSurveyId,
              leadId: siteSurvey.leadId,
              customerId: siteSurvey.customerId,
              projectTitle: projectName,
              erpProposalNumber: null,
              technicalDesc: technicalDescription,
              status: 'DRAFT',
              stage: 'DOCUMENT_GENERATION',
              generatedBy: userId,
            },
          });
          console.log('âš ï¸ Proposal saved after ERP error');
        }
      } // Close try-catch
    } // Close else if (!existingErpProposal)
    else {
      // Use existing proposal number
      proposalNumber = existingErpProposal?.erpProposalNumber || 'TRF>PENDING';
      console.log('â„¹ï¸ Using existing proposal number:', proposalNumber);
    }

    // Fetch full product details with specifications
    const productIds = allProducts.map((p: any) => p.id);
    const fullProducts = await prisma.product.findMany({
      where: { id: { in: productIds } },
      include: {
        images: true,
        translations: true,
        specifications: {
          include: {
            translations: true,
          },
          orderBy: { order: 'asc' },
        },
        brand: true,
        category: true,
      },
    });

    // Prepare template data
    const currentDate = new Date().toLocaleDateString('el-GR', {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
    });

    // Prepare products data for template
    const productsData = allProducts.map((p: any) => {
      const fullProduct = fullProducts.find(fp => fp.id === p.id);
      const greekTranslation = fullProduct?.translations?.find((t: any) => t.languageCode === 'el');
      
      // Get pricing from database (unitPrice already includes margin calculation)
      const pricing = productPricing[p.id] || {};
      const unitPrice = parseFloat(pricing.unitPrice || pricing.totalPrice || 0);
      const margin = parseFloat(pricing.margin || 0);
      const quantity = p.quantity || 1;
      const totalPrice = unitPrice * quantity;
      
      // Get specifications (filter out N/A)
      const specifications = fullProduct?.specifications
        ?.map((spec: any) => {
          const greekSpec = spec.translations.find((t: any) => t.languageCode === 'el');
          if (greekSpec && greekSpec.specValue && greekSpec.specValue !== 'N/A' && greekSpec.specValue.trim() !== '') {
            return `${greekSpec.specName}: ${greekSpec.specValue}`;
          }
          return null;
        })
        .filter(Boolean)
        .join('\n') || 'Î”ÎµÎ½ Ï…Ï€Î¬ÏÏ‡Î¿Ï…Î½ Ï€ÏÎ¿Î´Î¹Î±Î³ÏÎ±Ï†Î­Ï‚';

      return {
        name: greekTranslation?.name || fullProduct?.name || 'N/A',
        brand: fullProduct?.brand?.name || 'N/A',
        category: fullProduct?.category?.name || 'N/A',
        quantity: quantity,
        unitPrice: unitPrice,
        margin: margin,
        totalPrice: totalPrice,
        specifications,
      };
    });

    // Prepare services data for template
    const servicesData = allServices.map((s: any) => {
      // Get pricing from database (unitPrice already includes margin calculation)
      const pricing = servicePricing[s.id] || {};
      const unitPrice = parseFloat(pricing.unitPrice || pricing.totalPrice || 0);
      const quantity = s.quantity || 1;
      const totalPrice = unitPrice * quantity;
      
      return {
        name: s.name || 'N/A',
        category: s.category || 'N/A',
        quantity: quantity,
        unitPrice: unitPrice,
        totalPrice: totalPrice,
      };
    });

    // Calculate totals
    const totalProductsAmount = productsData.reduce((sum: number, p: any) => sum + (p.totalPrice || 0), 0);
    const totalServicesAmount = servicesData.reduce((sum: number, s: any) => sum + (s.totalPrice || 0), 0);
    const subtotal = totalProductsAmount + totalServicesAmount;
    const vatAmount = subtotal * 0.24; // 24% Greek VAT
    const grandTotal = subtotal + vatAmount;

    // Load template
    const templatePath = path.join(process.cwd(), 'public', 'templates', 'proposal-template.docx');
    
    if (!fs.existsSync(templatePath)) {
      console.error('âŒ Template file not found:', templatePath);
      return NextResponse.json(
        { error: 'Proposal template file not found' },
        { status: 500 }
      );
    }

    console.log('ğŸ“Š Using template to generate proposal document...');
    
    // Generate Infrastructure Description with OpenAI
    let infrastructureDescription = '';
    try {
      const step1Data = {
        title: siteSurvey.title,
        description: siteSurvey.description,
        address: siteSurvey.address,
        city: siteSurvey.city,
        type: siteSurvey.type,
      };
      
      const lastStepInfraDesc = infrastructureData?.infrastructureDesc || '';
      const wizardBuildings = infrastructureData?.wizardData?.buildings || [];
      
      // Prepare context for OpenAI
      const contextPrompt = `
Î”Î·Î¼Î¹Î¿ÏÏÎ³Î·ÏƒÎµ Î¼Î¹Î± Î»ÎµÏ€Ï„Î¿Î¼ÎµÏÎ® Ï€ÎµÏÎ¹Î³ÏÎ±Ï†Î® Ï…Ï€Î¿Î´Î¿Î¼Î®Ï‚ Î³Î¹Î± Ï„ÎµÏ‡Î½Î¹ÎºÎ® Ï€ÏÎ¿ÏƒÏ†Î¿ÏÎ¬ Î¼Îµ Î²Î¬ÏƒÎ· Ï„Î± ÎµÎ¾Î®Ï‚ Î´ÎµÎ´Î¿Î¼Î­Î½Î±:

Î£Î¤ÎŸÎ™Î§Î•Î™Î‘ ÎœÎ•Î›Î•Î¤Î—Î£:
- Î¤Î¯Ï„Î»Î¿Ï‚: ${step1Data.title || 'N/A'}
- Î ÎµÏÎ¹Î³ÏÎ±Ï†Î®: ${step1Data.description || 'N/A'}
- Î¤Î¿Ï€Î¿Î¸ÎµÏƒÎ¯Î±: ${step1Data.address || ''}, ${step1Data.city || ''}
- Î¤ÏÏ€Î¿Ï‚: ${step1Data.type || 'N/A'}

Î¥Î¦Î™Î£Î¤Î‘ÎœÎ•ÎÎ— Î¥Î ÎŸÎ”ÎŸÎœÎ—:
${lastStepInfraDesc || 'Î”ÎµÎ½ Ï…Ï€Î¬ÏÏ‡Î¿Ï…Î½ ÏƒÏ„Î¿Î¹Ï‡ÎµÎ¯Î±'}

ÎšÎ¤Î™Î¡Î™Î‘ & Î”ÎŸÎœÎ—:
${wizardBuildings.length > 0 ? JSON.stringify(wizardBuildings, null, 2) : 'Î”ÎµÎ½ Ï…Ï€Î¬ÏÏ‡Î¿Ï…Î½ Î´ÎµÎ´Î¿Î¼Î­Î½Î±'}

Î“ÏÎ¬ÏˆÎµ Î¼Î¹Î± ÎµÏ€Î±Î³Î³ÎµÎ»Î¼Î±Ï„Î¹ÎºÎ® Ï€ÎµÏÎ¹Î³ÏÎ±Ï†Î® Ï…Ï€Î¿Î´Î¿Î¼Î®Ï‚ (2-3 Ï€Î±ÏÎ¬Î³ÏÎ±Ï†Î¿Î¹) Ï€Î¿Ï… Î½Î± Ï€ÎµÏÎ¹Î»Î±Î¼Î²Î¬Î½ÎµÎ¹:
1. Î¤Î·Î½ Ï…Ï†Î¹ÏƒÏ„Î¬Î¼ÎµÎ½Î· ÎºÎ±Ï„Î¬ÏƒÏ„Î±ÏƒÎ·
2. Î¤Î¹Ï‚ Î±Î½Î¬Î³ÎºÎµÏ‚ Ï€Î¿Ï… ÎµÎ½Ï„Î¿Ï€Î¯ÏƒÏ„Î·ÎºÎ±Î½
3. Î¤Î·Î½ Ï€ÏÎ¿Ï„ÎµÎ¹Î½ÏŒÎ¼ÎµÎ½Î· Î»ÏÏƒÎ·

Î§ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¯Î·ÏƒÎµ ÎµÏ€Î¯ÏƒÎ·Î¼Î· Î³Î»ÏÏƒÏƒÎ± ÎºÎ±Ï„Î¬Î»Î»Î·Î»Î· Î³Î¹Î± Ï„ÎµÏ‡Î½Î¹ÎºÎ® Ï€ÏÎ¿ÏƒÏ†Î¿ÏÎ¬.`;

      const openaiResponse = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`,
        },
        body: JSON.stringify({
          model: 'gpt-4o',
          messages: [
            { role: 'system', content: 'Î•Î¯ÏƒÎ±Î¹ ÎµÎ¹Î´Î¹ÎºÏŒÏ‚ ÏƒÎµ Ï„Î·Î»ÎµÏ€Î¹ÎºÎ¿Î¹Î½Ï‰Î½Î¯ÎµÏ‚ ÎºÎ±Î¹ Î´Î¹ÎºÏ„Ï…Î±ÎºÎ­Ï‚ Ï…Ï€Î¿Î´Î¿Î¼Î­Ï‚ Ï€Î¿Ï… Î³ÏÎ¬Ï†ÎµÎ¹ Ï„ÎµÏ‡Î½Î¹ÎºÎ­Ï‚ Ï€ÏÎ¿ÏƒÏ†Î¿ÏÎ­Ï‚.' },
            { role: 'user', content: contextPrompt }
          ],
          temperature: 0.7,
          max_tokens: 1000,
        }),
      });

      if (openaiResponse.ok) {
        const openaiData = await openaiResponse.json();
        infrastructureDescription = openaiData.choices[0]?.message?.content || lastStepInfraDesc;
        console.log('âœ… Infrastructure description generated with OpenAI');
      } else {
        console.warn('âš ï¸ OpenAI API failed, using existing description');
        infrastructureDescription = lastStepInfraDesc;
      }
    } catch (error) {
      console.error('âš ï¸ Error generating infrastructure description:', error);
      infrastructureDescription = infrastructureData?.infrastructureDesc || 'Î— Ï€ÎµÏÎ¹Î³ÏÎ±Ï†Î® Ï…Ï€Î¿Î´Î¿Î¼Î®Ï‚ Î¸Î± Ï€ÏÎ¿ÏƒÏ„ÎµÎ¸ÎµÎ¯ ÏƒÏÎ½Ï„Î¿Î¼Î±.';
    }

    // Prepare template data matching your template placeholders
    const templateData = {
      PROJECT_TITLE: projectName,
      CUSTOMER_NAME: customerName,
      CUSTOMER_ADDRESS: siteSurvey.customer?.address || '',
      ERP_QUOTE_NUMBER: proposalNumber,
      DATE: currentDate,
      ASSIGNEE_NAME: siteSurvey.assignTo?.name || '',
      ASSIGNED_TO_NAME: siteSurvey.assignFrom?.name || '',
      PROJECT_DESCRIPTION: siteSurvey.description || '',
      PROJECT_SCOPE: infrastructureData?.projectScope || '',
      PROJECT_DURATION: infrastructureData?.projectDuration || '',
      INFRASTRUCTURE_DESC: infrastructureDescription,
      TECHNICAL_DESC: technicalDescription || 'Î— Ï„ÎµÏ‡Î½Î¹ÎºÎ® Ï€ÎµÏÎ¹Î³ÏÎ±Ï†Î® Î¸Î± Ï€ÏÎ¿ÏƒÏ„ÎµÎ¸ÎµÎ¯ ÏƒÏÎ½Ï„Î¿Î¼Î±.',
      GRAND_TOTAL: grandTotal.toFixed(2),
      // First product for single-value fields in template
      PRODUCT_NAME: productsData[0]?.name || '',
      BRAND: productsData[0]?.brand || '',
      QUANTITY: productsData[0]?.quantity || '',
      PRICE: productsData[0]?.unitPrice?.toFixed(2) || '',
      TOTAL: productsData[0]?.totalPrice?.toFixed(2) || '',
      PRODUCT_INDEX: '1',
    };
    
    console.log('ğŸ“„ Loading template and rendering...');
    const content = fs.readFileSync(templatePath, 'binary');
    const zip = new PizZip(content);
    
    const doc = new Docxtemplater(zip, {
      paragraphLoop: true,
      linebreaks: true,
    });
    
    doc.render(templateData);
    
    const buffer = doc.getZip().generate({
      type: 'nodebuffer',
      compression: 'DEFLATE',
    });
    
    console.log('âœ… Template rendered successfully');
    
    /* DETAILED PRODUCT SECTIONS WILL BE ADDED LATER
    allChildren.push(
      new Paragraph({
        children: [
          new TextRun({
            text: 'Î¤Î•Î§ÎÎ™ÎšÎ— Î Î¡ÎŸÎ¤Î‘Î£Î—',
            bold: true,
            size: 32,
            color: '1F4788',
          }),
        ],
        heading: HeadingLevel.HEADING_1,
        alignment: AlignmentType.CENTER,
        spacing: { before: 200, after: 300 },
      }),
      new Paragraph({
        children: [
          new TextRun({
            text: projectName,
            size: 26,
            bold: true,
          }),
        ],
        alignment: AlignmentType.CENTER,
        spacing: { after: 200 },
      }),
      new Paragraph({
        children: [
          new TextRun({
            text: customerName,
            size: 24,
          }),
        ],
        alignment: AlignmentType.CENTER,
        spacing: { after: 400 },
      }),
      new Paragraph({
        children: [
          new TextRun({
            text: `Î‘ÏÎ¹Î¸Î¼ÏŒÏ‚ Î ÏÎ¿ÏƒÏ†Î¿ÏÎ¬Ï‚: ${proposalNumber}`,
            size: 22,
          }),
        ],
        spacing: { after: 100 },
      }),
      new Paragraph({
        children: [
          new TextRun({
            text: `Î—Î¼ÎµÏÎ¿Î¼Î·Î½Î¯Î±: ${currentDate}`,
            size: 22,
          }),
        ],
        spacing: { after: 400 },
      })
    );
    
    // ========================================
    // INFRASTRUCTURE DESCRIPTION
    // ========================================
    allChildren.push(
      new Paragraph({
        children: [
          new TextRun({
            text: 'Î Î•Î¡Î™Î“Î¡Î‘Î¦Î— Î¥Î ÎŸÎ”ÎŸÎœÎ—Î£',
            bold: true,
            size: 26,
            color: '1F4788',
          }),
        ],
        heading: HeadingLevel.HEADING_2,
        spacing: { before: 400, after: 200 },
      }),
      new Paragraph({
        children: [
          new TextRun({
            text: infrastructureDescription || 'Î— Ï€ÎµÏÎ¹Î³ÏÎ±Ï†Î® Ï…Ï€Î¿Î´Î¿Î¼Î®Ï‚ Î¸Î± Ï€ÏÎ¿ÏƒÏ„ÎµÎ¸ÎµÎ¯ ÏƒÏÎ½Ï„Î¿Î¼Î±.',
            size: 22,
          }),
        ],
        alignment: AlignmentType.JUSTIFIED,
        spacing: { after: 300 },
      })
    );
    
    // ========================================
    // TECHNICAL DESCRIPTION
    // ========================================
    if (technicalDescription) {
      allChildren.push(
        new Paragraph({
          children: [
            new TextRun({
              text: 'Î¤Î•Î§ÎÎ™ÎšÎ— Î Î•Î¡Î™Î“Î¡Î‘Î¦Î—',
              bold: true,
              size: 26,
              color: '1F4788',
            }),
          ],
          heading: HeadingLevel.HEADING_2,
          spacing: { before: 400, after: 200 },
        }),
        new Paragraph({
          children: [
            new TextRun({
              text: technicalDescription,
              size: 22,
            }),
          ],
          alignment: AlignmentType.JUSTIFIED,
          spacing: { after: 300 },
        })
      );
    }
    
    // ========================================
    // PRODUCTS SECTION WITH IMAGES & TABLE
    // ========================================
    allChildren.push(
      new Paragraph({
        children: [
          new TextRun({
            text: 'Î Î¡ÎŸÎªÎŸÎÎ¤Î‘',
            bold: true,
            size: 28,
            color: '1F4788',
          }),
        ],
        heading: HeadingLevel.HEADING_2,
        spacing: { before: 600, after: 300 },
      })
    );
    
    // Add each product with image and details
    for (let index = 0; index < productsData.length; index++) {
      const product = productsData[index];
      const fullProduct = fullProducts.find((p) => p.id === product.id);
      
      // Product Name
      allChildren.push(
        new Paragraph({
          children: [
            new TextRun({
              text: `${index + 1}. ${product.name}`,
              bold: true,
              size: 24,
              color: 'FF0000',
            }),
          ],
          spacing: { before: 400, after: 200 },
        })
      );
      
      // Product Image
      if (fullProduct?.images && fullProduct.images.length > 0) {
        try {
          const imageUrl = fullProduct.images[0].url;
          console.log(`ğŸ–¼ï¸ Downloading image for product ${product.id}:`, imageUrl);
          
          const imageResponse = await fetch(imageUrl);
          if (imageResponse.ok) {
            const imageBuffer = await imageResponse.arrayBuffer();
            const imageType = imageUrl.toLowerCase().endsWith('.png') ? 'png' : 'jpg';
            
            console.log(`âœ… Image downloaded: ${imageBuffer.byteLength} bytes`);
            
            allChildren.push(
              new Paragraph({
                children: [
                  new ImageRun({
                    data: Buffer.from(imageBuffer),
                    transformation: {
                      width: 300,
                      height: 300,
                    },
                    type: imageType,
                  }),
                ],
                alignment: AlignmentType.CENTER,
                spacing: { before: 200, after: 200 },
              })
            );
          }
        } catch (error) {
          console.error(`âŒ Error loading image for product ${product.id}:`, error);
        }
      }
      
      // Product Details
      allChildren.push(
        new Paragraph({
          children: [
            new TextRun({ text: 'ÎœÎ¬ÏÎºÎ±: ', bold: true, size: 22 }),
            new TextRun({ text: product.brand || 'N/A', size: 22 }),
          ],
          spacing: { after: 100 },
        }),
        new Paragraph({
          children: [
            new TextRun({ text: 'ÎšÎ±Ï„Î·Î³Î¿ÏÎ¯Î±: ', bold: true, size: 22 }),
            new TextRun({ text: product.category || 'N/A', size: 22 }),
          ],
          spacing: { after: 100 },
        }),
        new Paragraph({
          children: [
            new TextRun({ text: 'Î Î¿ÏƒÏŒÏ„Î·Ï„Î±: ', bold: true, size: 22 }),
            new TextRun({ text: product.quantity?.toString() || '0', size: 22 }),
          ],
          spacing: { after: 100 },
        }),
        new Paragraph({
          children: [
            new TextRun({ text: 'Î¤Î¹Î¼Î® ÎœÎ¿Î½Î¬Î´Î±Ï‚: ', bold: true, size: 22 }),
            new TextRun({ text: `â‚¬${product.unitPrice?.toFixed(2) || '0.00'}`, size: 22 }),
          ],
          spacing: { after: 100 },
        }),
        new Paragraph({
          children: [
            new TextRun({ text: 'Î ÎµÏÎ¹Î¸ÏÏÎ¹Î¿: ', bold: true, size: 22 }),
            new TextRun({ text: `${product.margin || 0}%`, size: 22 }),
          ],
          spacing: { after: 100 },
        }),
        new Paragraph({
          children: [
            new TextRun({ text: 'Î£ÏÎ½Î¿Î»Î¿: ', bold: true, size: 22, color: 'FF0000' }),
            new TextRun({ text: `â‚¬${product.totalPrice?.toFixed(2) || '0.00'}`, size: 22, bold: true, color: 'FF0000' }),
          ],
          spacing: { after: 200 },
        })
      );
      
      // Specifications
      if (product.specifications && product.specifications.trim()) {
        allChildren.push(
          new Paragraph({
            children: [
              new TextRun({
                text: 'Î ÏÎ¿Î´Î¹Î±Î³ÏÎ±Ï†Î­Ï‚:',
                bold: true,
                size: 22,
              }),
            ],
            spacing: { before: 100, after: 100 },
          }),
          new Paragraph({
            children: [
              new TextRun({
                text: product.specifications,
                size: 20,
              }),
            ],
            spacing: { after: 300 },
          })
        );
      }
    }
    
    // ========================================
    // SERVICES SECTION
    // ========================================
    if (servicesData.length > 0) {
      allChildren.push(
        new Paragraph({
          children: [
            new TextRun({
              text: 'Î¥Î Î—Î¡Î•Î£Î™Î•Î£',
              bold: true,
              size: 28,
              color: '1F4788',
            }),
          ],
          heading: HeadingLevel.HEADING_2,
          spacing: { before: 600, after: 300 },
        })
      );
      
      servicesData.forEach((service: any, index: number) => {
        allChildren.push(
          new Paragraph({
            children: [
              new TextRun({
                text: `${index + 1}. ${service.name}`,
                bold: true,
                size: 24,
              }),
            ],
            spacing: { before: 300, after: 100 },
          }),
          new Paragraph({
            children: [
              new TextRun({ text: 'Î Î¿ÏƒÏŒÏ„Î·Ï„Î±: ', bold: true, size: 22 }),
              new TextRun({ text: service.quantity?.toString() || '0', size: 22 }),
            ],
            spacing: { after: 100 },
          }),
          new Paragraph({
            children: [
              new TextRun({ text: 'Î¤Î¹Î¼Î® ÎœÎ¿Î½Î¬Î´Î±Ï‚: ', bold: true, size: 22 }),
              new TextRun({ text: `â‚¬${service.unitPrice?.toFixed(2) || '0.00'}`, size: 22 }),
            ],
            spacing: { after: 100 },
          }),
          new Paragraph({
            children: [
              new TextRun({ text: 'Î£ÏÎ½Î¿Î»Î¿: ', bold: true, size: 22, color: 'FF0000' }),
              new TextRun({ text: `â‚¬${service.totalPrice?.toFixed(2) || '0.00'}`, size: 22, bold: true, color: 'FF0000' }),
            ],
            spacing: { after: 300 },
          })
        );
      });
    }
    
    // ========================================
    // FULL PRODUCTS & SERVICES PRICING TABLE
    // ========================================
    allChildren.push(
      new Paragraph({
        children: [
          new TextRun({
            text: 'ÎŸÎ™ÎšÎŸÎÎŸÎœÎ™ÎšÎ— Î Î¡ÎŸÎ¤Î‘Î£Î— - Î‘ÎÎ‘Î›Î¥Î¤Î™ÎšÎŸÎ£ Î Î™ÎÎ‘ÎšÎ‘Î£',
            bold: true,
            size: 28,
            color: '1F4788',
          }),
        ],
        heading: HeadingLevel.HEADING_2,
        spacing: { before: 600, after: 300 },
      })
    );
    
    // Build table rows for all products and services
    const tableRows = [
      // Header row
      new TableRow({
        children: [
          new TableCell({
            children: [new Paragraph({ children: [new TextRun({ text: 'Î‘/Î‘', bold: true, size: 20 })], alignment: AlignmentType.CENTER })],
            width: { size: 8, type: WidthType.PERCENTAGE },
          }),
          new TableCell({
            children: [new Paragraph({ children: [new TextRun({ text: 'Î ÎµÏÎ¹Î³ÏÎ±Ï†Î®', bold: true, size: 20 })] })],
            width: { size: 37, type: WidthType.PERCENTAGE },
          }),
          new TableCell({
            children: [new Paragraph({ children: [new TextRun({ text: 'ÎœÎ¬ÏÎºÎ±', bold: true, size: 20 })] })],
            width: { size: 15, type: WidthType.PERCENTAGE },
          }),
          new TableCell({
            children: [new Paragraph({ children: [new TextRun({ text: 'Î Î¿Ïƒ.', bold: true, size: 20 })], alignment: AlignmentType.CENTER })],
            width: { size: 10, type: WidthType.PERCENTAGE },
          }),
          new TableCell({
            children: [new Paragraph({ children: [new TextRun({ text: 'Î¤Î¹Î¼Î®', bold: true, size: 20 })], alignment: AlignmentType.RIGHT })],
            width: { size: 15, type: WidthType.PERCENTAGE },
          }),
          new TableCell({
            children: [new Paragraph({ children: [new TextRun({ text: 'Î£ÏÎ½Î¿Î»Î¿', bold: true, size: 20 })], alignment: AlignmentType.RIGHT })],
            width: { size: 15, type: WidthType.PERCENTAGE },
          }),
        ],
      }),
    ];
    
    // Add all products to table
    productsData.forEach((product: any, index: number) => {
      tableRows.push(
        new TableRow({
          children: [
            new TableCell({
              children: [new Paragraph({ children: [new TextRun({ text: (index + 1).toString(), size: 20 })], alignment: AlignmentType.CENTER })],
            }),
            new TableCell({
              children: [new Paragraph({ children: [new TextRun({ text: product.name || 'N/A', size: 20 })] })],
            }),
            new TableCell({
              children: [new Paragraph({ children: [new TextRun({ text: product.brand || 'N/A', size: 20 })] })],
            }),
            new TableCell({
              children: [new Paragraph({ children: [new TextRun({ text: product.quantity?.toString() || '0', size: 20 })], alignment: AlignmentType.CENTER })],
            }),
            new TableCell({
              children: [new Paragraph({ children: [new TextRun({ text: `â‚¬${product.unitPrice?.toFixed(2) || '0.00'}`, size: 20 })], alignment: AlignmentType.RIGHT })],
            }),
            new TableCell({
              children: [new Paragraph({ children: [new TextRun({ text: `â‚¬${product.totalPrice?.toFixed(2) || '0.00'}`, size: 20, bold: true })], alignment: AlignmentType.RIGHT })],
            }),
          ],
        })
      );
    });
    
    // Add all services to table
    servicesData.forEach((service: any, index: number) => {
      tableRows.push(
        new TableRow({
          children: [
            new TableCell({
              children: [new Paragraph({ children: [new TextRun({ text: (productsData.length + index + 1).toString(), size: 20 })], alignment: AlignmentType.CENTER })],
            }),
            new TableCell({
              children: [new Paragraph({ children: [new TextRun({ text: service.name || 'N/A', size: 20, italic: true })] })],
            }),
            new TableCell({
              children: [new Paragraph({ children: [new TextRun({ text: 'Î¥Ï€Î·ÏÎµÏƒÎ¯Î±', size: 20, italic: true })] })],
            }),
            new TableCell({
              children: [new Paragraph({ children: [new TextRun({ text: service.quantity?.toString() || '0', size: 20 })], alignment: AlignmentType.CENTER })],
            }),
            new TableCell({
              children: [new Paragraph({ children: [new TextRun({ text: `â‚¬${service.unitPrice?.toFixed(2) || '0.00'}`, size: 20 })], alignment: AlignmentType.RIGHT })],
            }),
            new TableCell({
              children: [new Paragraph({ children: [new TextRun({ text: `â‚¬${service.totalPrice?.toFixed(2) || '0.00'}`, size: 20, bold: true })], alignment: AlignmentType.RIGHT })],
            }),
          ],
        })
      );
    });
    
    // Add totals rows
    tableRows.push(
      // Subtotal
      new TableRow({
        children: [
          new TableCell({ children: [new Paragraph('')], columnSpan: 5 }),
          new TableCell({
            children: [new Paragraph({ children: [new TextRun({ text: `â‚¬${subtotal.toFixed(2)}`, bold: true, size: 22 })], alignment: AlignmentType.RIGHT })],
          }),
        ],
      }),
      // VAT
      new TableRow({
        children: [
          new TableCell({
            children: [new Paragraph({ children: [new TextRun({ text: 'Î¦Î Î‘ 24%', size: 20 })], alignment: AlignmentType.RIGHT })],
            columnSpan: 5,
          }),
          new TableCell({
            children: [new Paragraph({ children: [new TextRun({ text: `â‚¬${vatAmount.toFixed(2)}`, size: 22 })], alignment: AlignmentType.RIGHT })],
          }),
        ],
      }),
      // Grand Total
      new TableRow({
        children: [
          new TableCell({
            children: [new Paragraph({ children: [new TextRun({ text: 'Î“Î•ÎÎ™ÎšÎŸ Î£Î¥ÎÎŸÎ›ÎŸ', bold: true, size: 22, color: 'FF0000' })], alignment: AlignmentType.RIGHT })],
            columnSpan: 5,
          }),
          new TableCell({
            children: [new Paragraph({ children: [new TextRun({ text: `â‚¬${grandTotal.toFixed(2)}`, bold: true, size: 24, color: 'FF0000' })], alignment: AlignmentType.RIGHT })],
          }),
        ],
      })
    );
    
    const fullPricingTable = new Table({
      width: { size: 100, type: WidthType.PERCENTAGE },
      rows: tableRows,
    });
    
    allChildren.push(fullPricingTable);
    
    // ========================================
    // CREATE DOCUMENT
    // ========================================
    const doc = new Document({
      sections: [{
        properties: {
          page: {
            margin: {
              top: 1440,
              right: 1440,
              bottom: 1440,
              left: 1440,
            },
          },
        },
        children: allChildren,
      }],
    });
    
    // Generate buffer
    const buffer = await Packer.toBuffer(doc);
    console.log('âœ… Complete proposal document generated programmatically');

    // Save to database with versioning
    const baseFileName = `Complete-Proposal_${siteSurvey.title || 'SiteSurvey'}_${new Date().toISOString().split('T')[0]}`;
    
    const { nextVersion } = await manageDocumentVersions({
      entityType: 'SITESURVEY',
      entityId: siteSurveyId,
      documentType: 'complete-proposal',
      baseFileName,
      fileExtension: 'docx',
    });

    const versionedFilename = generateVersionedFilename(baseFileName, nextVersion, 'docx');

    console.log('ğŸ“¤ Uploading complete proposal to BunnyCDN:', versionedFilename);

    const uploadResult = await uploadFileToBunny(
      Buffer.from(buffer),
      versionedFilename,
      'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
    );

    console.log('âœ… Complete proposal uploaded:', uploadResult.url);

    await prisma.file.create({
      data: {
        name: versionedFilename,
        url: uploadResult.url,
        filetype: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
        size: buffer.byteLength,
        type: 'SITESURVEY',
        entityId: siteSurveyId,
      },
    });

    // Return the document for download
    return new NextResponse(Buffer.from(buffer), {
      status: 200,
      headers: {
        'Content-Type': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
        'Content-Disposition': `attachment; filename="${encodeURIComponent(versionedFilename)}"`,
      },
    });
    
  } catch (error: any) {
    console.error('âŒ Error generating complete proposal:', error);
    return NextResponse.json(
      {
        error: 'Failed to generate complete proposal',
        details: error.message,
      },
      { status: 500 }
    );
  }
}

