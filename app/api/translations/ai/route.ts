import { NextRequest, NextResponse } from "next/server";
import { z } from "zod";
import { prisma } from "@/lib/db/prisma";
import { requireAdmin } from "@/lib/auth/guards";
import { deepseekChat } from "@/lib/ai/deepseek";

const aiTranslateSchema = z.object({
  translationKeyIds: z.array(z.string()).optional(),
  category: z.string().optional(),
  sourceLang: z.enum(["el", "en"]).default("en"),
  targetLang: z.enum(["el", "en"]).default("el"),
  batchName: z.string().optional(),
});

// POST /api/translations/ai
export async function POST(request: NextRequest) {
  try {
    const session = await requireAdmin();
    const body = await request.json();
    const { translationKeyIds, category, sourceLang, targetLang, batchName } = aiTranslateSchema.parse(body);

    // Get translation keys to translate
    let translationKeys;
    if (translationKeyIds && translationKeyIds.length > 0) {
      translationKeys = await prisma.translationKey.findMany({
        where: { id: { in: translationKeyIds } },
        include: {
          translations: { where: { languageCode: sourceLang } },
        },
      });
    } else if (category) {
      translationKeys = await prisma.translationKey.findMany({
        where: { category },
        include: {
          translations: { where: { languageCode: sourceLang } },
        },
      });
    } else {
      // Translate ALL keys when no ids/category provided
      translationKeys = await prisma.translationKey.findMany({
        include: { translations: { where: { languageCode: sourceLang } } },
      });
    }

    if (translationKeys.length === 0) {
      return NextResponse.json(
        { message: "No translation keys found" },
        { status: 404 }
      );
    }

    // Create batch if batchName is provided
    let batch;
    if (batchName) {
      batch = await prisma.translationBatch.create({
        data: {
          name: batchName,
          description: `AI translation batch for ${translationKeys.length} keys`,
          sourceLangCode: sourceLang,
          targetLangCode: targetLang,
          totalKeys: translationKeys.length,
          status: "processing",
        },
      });
    }

    const results = [];
    let processedCount = 0;
    let failedCount = 0;

    // Process translations in chunks to avoid rate limits
    const chunkSize = 5;
    for (let i = 0; i < translationKeys.length; i += chunkSize) {
      const chunk = translationKeys.slice(i, i + chunkSize);
      
      const chunkPromises = chunk.map(async (translationKey) => {
        try {
          const sourceTranslation = translationKey.translations[0];
          if (!sourceTranslation) {
            failedCount++;
            return { key: translationKey.key, error: "No source translation found" };
          }

          // Prepare context for AI
          const context = `
            Context: This is a translation for a CRM system interface.
            Key: ${translationKey.key}
            Category: ${translationKey.category}
            ${translationKey.description ? `Description: ${translationKey.description}` : ''}
            
            Please translate the following text from ${sourceLang.toUpperCase()} to ${targetLang.toUpperCase()}:
            "${sourceTranslation.value}"
            
            Requirements:
            - Keep the translation concise and professional
            - Maintain the same tone and style
            - Use appropriate business/CRM terminology
            - If it's a button or action, keep it short and clear
            - If it's a form label, make it descriptive but concise
            
            Return only the translated text, nothing else.
          `;

          const translatedText = await deepseekChat(
            "You are a professional translator specializing in business software interfaces. Translate the given text accurately while maintaining the appropriate tone and terminology for a CRM system.",
            context
          );

          if (!translatedText || translatedText.trim().length === 0) {
            throw new Error("Empty translation received");
          }

          // Save the translation
          const translation = await prisma.translation.upsert({
            where: {
              translationKeyId_languageCode_pluralForm: {
                translationKeyId: translationKey.id,
                languageCode: targetLang,
                pluralForm: sourceTranslation.pluralForm,
              },
            },
            update: {
              value: translatedText.trim(),
              isAutoGenerated: true,
              lastUpdatedBy: session.user.id,
              ...(batch && { batchId: batch.id }),
            },
            create: {
              translationKeyId: translationKey.id,
              languageCode: targetLang,
              value: translatedText.trim(),
              pluralForm: sourceTranslation.pluralForm,
              isAutoGenerated: true,
              lastUpdatedBy: session.user.id,
              ...(batch && { batchId: batch.id }),
            },
          });

          processedCount++;
          return { key: translationKey.key, success: true, translation: translation.value };
        } catch (error) {
          console.error(`Translation failed for key ${translationKey.key}:`, error);
          failedCount++;
          return { key: translationKey.key, error: error instanceof Error ? error.message : "Unknown error" };
        }
      });

      const chunkResults = await Promise.all(chunkPromises);
      results.push(...chunkResults);

      // Update batch progress
      if (batch) {
        await prisma.translationBatch.update({
          where: { id: batch.id },
          data: {
            processedKeys: processedCount,
            failedKeys: failedCount,
          },
        });
      }

      // Small delay to avoid rate limits
      if (i + chunkSize < translationKeys.length) {
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }

    // Update batch status
    if (batch) {
      await prisma.translationBatch.update({
        where: { id: batch.id },
        data: {
          status: failedCount > 0 ? "completed_with_errors" : "completed",
          completedAt: new Date(),
        },
      });
    }

    return NextResponse.json({
      message: `Translation completed: ${processedCount} successful, ${failedCount} failed`,
      processedCount,
      failedCount,
      results,
      batchId: batch?.id,
    });
  } catch (error) {
    console.error('AI Translation error:', error);
    
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { message: "Invalid data", errors: error.errors },
        { status: 400 }
      );
    }

    return NextResponse.json(
      { message: "Failed to process AI translation" },
      { status: 500 }
    );
  }
}
