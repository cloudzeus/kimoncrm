import { NextRequest, NextResponse } from "next/server";
import { z } from "zod";
import { prisma } from "@/lib/db/prisma";
import { requireAdmin } from "@/lib/auth/guards";

const createTranslationKeySchema = z.object({
  key: z.string().min(1),
  category: z.string().default("general"),
  description: z.string().optional(),
  isPlural: z.boolean().default(false),
});

const createTranslationSchema = z.object({
  translationKeyId: z.string(),
  languageCode: z.enum(["el", "en"]),
  value: z.string().min(1),
  pluralForm: z.string().optional(),
});

const updateTranslationSchema = z.object({
  translationKeyId: z.string(),
  language: z.enum(["el", "en"]),
  value: z.string().min(1),
  pluralForm: z.string().optional(),
});

// GET /api/translations
export async function GET(request: NextRequest) {
  try {
    await requireAdmin();
    
    const { searchParams } = new URL(request.url);
    const category = searchParams.get('category') || '';
    const language = searchParams.get('language') || 'el';
    const sourceLang = searchParams.get('sourceLang') || 'en';
    const search = searchParams.get('search') || '';
    const page = Math.max(1, Number(searchParams.get('page') || '1'));
    const pageSize = Math.min(100, Math.max(1, Number(searchParams.get('pageSize') || '25')));

    const where = {
      ...(category && { category }),
      ...(search && {
        OR: [
          { key: { contains: search } },
          { description: { contains: search } },
        ],
      }),
    };

    const [total, translationKeys] = await Promise.all([
      prisma.translationKey.count({ where }),
      prisma.translationKey.findMany({
      where,
      include: {
        translations: { where: { languageCode: { in: [sourceLang, language] } } },
      },
        orderBy: { key: 'asc' },
        skip: (page - 1) * pageSize,
        take: pageSize,
      }),
    ]);

    return NextResponse.json({ translationKeys, total, page, pageSize });
  } catch (error) {
    console.error('Translations GET error:', error);
    return NextResponse.json(
      { message: "Failed to fetch translations" },
      { status: 500 }
    );
  }
}

// POST /api/translations (Create translation key)
export async function POST(request: NextRequest) {
  try {
    await requireAdmin();
    
    const body = await request.json();
    const data = createTranslationKeySchema.parse(body);

    const translationKey = await prisma.translationKey.create({
      data,
      include: {
        translations: true,
      },
    });

    return NextResponse.json(translationKey, { status: 201 });
  } catch (error) {
    console.error('Translations POST error:', error);
    
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { message: "Invalid data", errors: error.issues },
        { status: 400 }
      );
    }

    return NextResponse.json(
      { message: "Failed to create translation key" },
      { status: 500 }
    );
  }
}

// PUT /api/translations (Update translation)
export async function PUT(request: NextRequest) {
  try {
    await requireAdmin();
    
    const body = await request.json();
    const { translationKeyId, language, ...data } = updateTranslationSchema.parse(body);

    const translation = await prisma.translation.upsert({
      where: {
        translationKeyId_languageCode_pluralForm: {
          translationKeyId,
          languageCode: language,
          pluralForm: data.pluralForm || null,
        },
      },
      update: {
        ...data,
        isAutoGenerated: false,
      },
      create: {
        translationKeyId,
        languageCode: language,
        ...data,
        isAutoGenerated: false,
      },
      include: {
        translationKey: true,
      },
    });

    return NextResponse.json(translation);
  } catch (error) {
    console.error('Translations PUT error:', error);
    
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { message: "Invalid data", errors: error.issues },
        { status: 400 }
      );
    }

    return NextResponse.json(
      { message: "Failed to update translation" },
      { status: 500 }
    );
  }
}
